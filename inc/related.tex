\chapter{Background and Related Work}
\label{chap:related}

\section{Related Work}

The work already done on blockchain analysis does not consider the LN as it was done before the LN was conceived of. There is therefore no available work that answers the research question: what information about the LN and its users can be revealed through data in the blockchain?
But the methods used, and how information is deduced from the data contained there can be nevertheless be helpful for this project.
Because the blockchain is a public distributed datastructure containing all transactions done by every Bitcoin user, it is by its nature something that limits privacy. By analyzing the blockchain one can potentially find records of all transactions related to an individual. The amount sent and received, the time and date this was done, and which addresses these transactions was going to or coming from. But as mentioned these addresses used can be generated by users at will. Therefore it is considered best practice to use a new address for each transaction. The result of this is that we have transactions between addresses without knowing which addresses belong to which users. Therefore the goal of the studies who analyzed blockchain data was to cluster addresses used by the same individual, and negate the effect of users creating multiple addresses for different transactions \cite{herrera2015research}, and by doing this also creating user profiles that contain transaction data for that user.

\paragraph{}
One of the first studies which analyzed data from the blockchain to assess privacy was done by Reid and Harrigan \cite{reid2013analysis}.
They used the data to construct two networks, one transaction network and one user network. A Bitcoin transaction stored in the blockchain has at least one input and one output. A output of one transaction will eventually be an input on another. A network created with this transaction data will show how transactions are connected and therefore how founds are moving. The user network tries to link addresses which are likely to belong to the same user. This will create a network were we can see relations between different users. We can also see the transactions were the addresses of a particular user is involved. This clustering of addresses was done in two ways: the input addresses of a transaction with multiple inputs was assumed to be from the same user; the other way was using online sources and online Bitcoin services which had information linking multiple addresses to one user. The review paper by Herrera-Joancomart\́i\cite{herrera2015research} states that this user network model allowed Reid and Harrigan do user centered analysis, and therefore give context to the data in the blockchain.

\paragraph{}
Another paper trying to do address clustering is Androulaki et al. \cite{androulaki2013evaluating}, were they in addition to grouping multiple input addresses for a transaction to the same user, they also utilized the output. Since a single unspent output must be consumed in its entirety by a input for a new transaction, transactions will often generate change. E.g., a user has a 5 coin unspent output available and they are paying someone else 4 coins; the payment transaction will have one output with 4 to the other user, and one output back to the sender with the remaining 1 coin. The address this change is sent to is referred to in the paper by Androulaki et al. as a shadow address. It will not be the same address which was used send the payment but will be a new one belonging to the sender.
To identify which address belonged to the receiver and which is the shadow address they looked at the addresses previously used in the blockchain. The shadow address was assumed to be newly created to receive the change so if one of the output addresses had already appeared in the blockchain they assumed it to be the receiver reusing an address. They also utilized machine learning techniques to further group addresses based on behaviour. They were able to unveil 40\% of user profiles in their experiment. This accurate figure is made possible by having a ground truth, because the data used was from a simulated use of Bitcoin.

\paragraph{}
A more active approach to help clustering addresses is actively participating in the network to collect data, which was used in a study by Meiklejohn et al. \cite{meiklejohn2013fistful}. They participated in mining pools, withdrew and deposited founds on banking services or wallet services, used gambling sites, and purchased goods from vendors. Doing this they could gather addresses and because the addresses collected was certain to belong to a known entity, the tagged addresses would aid clustering in addition to the methods described earlier.
A important remark done both by Meiklejohn et al.\cite{meiklejohn2013fistful} and Reid and Herrigan \cite{reid2013analysis} is that a big entity in the network which does transactions with a large number of other users will have greater opportunity to identify or track users. Such a entity might be a exchange were people trade real money for Bitcoin, in such cases services will most likely have identifying information of users linked to their addresses.

\paragraph{}
In the LN the blockchain is used to open and close payment channels between a pair of nodes \cite{poon2015bitcoin} \cite{malavolta2017concurrency}. These payment channels between nodes form a network which is the LN itself, and were payments can be transferred between two parties without the two needing to have their own payment channel; meaning the payment is routed through the payment channels of intermediary nodes.
Herrera-Joancomartí et al. discusses in their paper \cite{herrera2016privacy} privacy in relation to Bitcoin scaling solutions and also points to several problems with blockhain analysis. One central issue is the sheer size of the blockchain. Herrera-Joancomartí et al. states that at the time of writing that paper the blockchain was 72 GB. The other papers discussed here which did blockchain analysis, did so in 2013 when the blockchain was around 8 GB; now it is over 140 GB \cite{blockchain_size}. 
Herrera-Joancomartí et al. also points out that the clustering heuristics used in previous studies \cite{reid2013analysis}  \cite{meiklejohn2013fistful} are no longer applicable when considering off-chain transactions. Also the transactions themselves that are done off-chain will not be available in the blockchain for analysis. Herrera-Joancomartí et al. suggests that using payment channel networks will increase the privacy of users with regards to blockchain analysis, but that the existing methods may be adapted to analyze the payment channels in a network such as the LN. In the LN paper \cite{poon2015bitcoin} the transaction used to open a channel is referred to as the founding transaction. The output of this transaction is used as input of the transaction closing the channel-i.e., the founding (opening) transaction and closing transaction is linkable. Furthermore, in the LN developer mailing list there is mention of the founding (here referred to as anchor) transaction can imply the network topology \cite{rusty_routing1}. This is because all channels must be anchored in the blockchain with a founding transaction signed by both parties in the channel. This possibility is also mentioned in the LN paper itself \cite{poon2015bitcoin}: by monitoring the blockchain for founding transactions a routing map of can be theoretically built. We do not know whether or not this possibility has been explored any further.

\section{Network Analysis}

There has been no studies doing network analysis on the LN or other payment channel networks.
However, there has been identified several factors in the LN that will impact anonymity.
Herrera-Joancomartí et al. \cite{herrera2016privacy} suggest that the typology of the LN will greatly affect privacy. 
They propose that a possible typology for the LN is one were there are some highly connected core nodes that have big capacity channels with each other, while the end users connect to one of these each when they want to do transactions. In contrast to the Bitcoin network which is a decentralized p2p network, the LN with this topology will be a more centralized one. The number of core nodes and how many connections they have will of course play a big role in the degree of centralization. But any degree of centralization with some nodes being more connected than others will likely have a effect on anonymity. These nodes may be in a position to know both source and destination of payment done in the network. Which violates the privacy notion of relationship anonymity for payment channel networks suggested by Malavolta et al. \cite{malavolta2017concurrency} discussed in section 2.1.
However, onion routing \cite{LN_onion_implementation} has been implemented for the LN which provides relationship anonymity.
In the payment path a node will only know where it received the payment from and where to forward it to. It cannot know if where it received it from was the sender or just another node in the path, or if the next node is the final receiver or just another forwarder. 

\paragraph{}
The mechanism used to transfer the payments over multiple channels in the LN is called Hashed Timelock Contract (HTLC). This contract states that the receiver must supply a preimage (input used in a hash function) to claim the founds from the contract; if this is not done within some time frame the sender will get their founds back. Each node in the path, from the sender to receiver promises to pay the next node by using the HTLC. So, a HTLC between two nodes is created for each hop in the path. The final receiver then discloses the preimage to the node before it in the path, which in turn can now get the founds from the node before it because it now knows the preimage.  This happens until the founds are pulled from the original sender. The term contract is used because if one of the nodes breaches the terms, the contract can still be enforced by using the blockchain to broadcast transaction data and close out the channel to claim the founds. In this manner two parties can transfer founds in a payment path containing untrusted intermediaries. Malavolta et al. \cite{malavolta2017concurrency} points out that this preimage is the same for each HTLC in the path for a payment, it can therefore be used as an identifier among many payments done by the nodes in the network. This means that two nodes can determine that they both where in the path of of the same payment by comparing preimage value. They also suggest that if a node in the path is uncooperative and the HTLC is enforced on the blockchain, the data broadcast there containing the preimage can be used to find the path used for the payment, even without being part of the payment path.

\section{Background}

\subsection{Transactions}

The transactions in the Bitcoin network are how value is transferred between users, but they are also the value themselves.
The coins are more of an abstraction which we can see in Satoshi Nakamoto's definition of a coin: "We define a coin as a chain of digital signatures" \cite{nakamoto2008bitcoin}.
Public key cryptography is used to control transactions; meaning a transaction is tied or owned by a public-private key pair.
To transfer the value of a transaction to another entity, the owner of the key pair locks the transaction using the public key of the recipient, and then uses their own private key to generate a signature showing that the transfer was done by the now previous owner of the transaction. The lock placed on the transaction by the previous owner makes the recipient the one in control of the transaction as they control the private key corresponding to the public one used to lock the transaction. Everyone else  can verify this transfer since the previous owner generated a signature using their private key showing that they had control of the key pair controlling the transaction at the time of the transfer. The datastructure used for transactions represents one transfer of founds from one or more previous transactions; creating a chain of signatures contained in transactions. All previous transactions within this chain can no longer be spent since they have already been transferred, so it is only the tip of the chain which are available to the owner of the key pair controlling it. However, this chain have the ability to fork and merge creating the possibility to split the value of one transaction, or merge the value of many into a single transaction. 
With the possibility of splitting value of a transaction a key pair might not control the entire value of a transaction. We should instead think of ownership of transactions outputs; which together with transaction inputs are the two main parts of a transactions. The output(s) of a transaction is where the creator of the transaction locks the value to a public key, and with multiple outputs can give different keys control of different outputs. Transaction inputs are outputs of previous transactions telling us which value the transaction transfers as shown in fig.\ref{fig:transaction}. As noted earlier, a spent transaction (output) can not be spent again since it is no longer the tip of the chain. This means that if the value given in the input(s) is not used in it's entirety in the output(s) the value missing from the output will be lost. If the creator of a transaction does not wish to transfer the entire value to another entity they can create a output which is locked to their own public key. Similarly there is no output with sufficiently large value for a transfer the sender can crate many inputs from different available outputs to reach the desired value of the transaction. 

\begin{figure}[h]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.7\textwidth]{figures/transaction}
  \caption[Transaction chain]{A section of a example transaction chain. We see how outputs of previous transactions become inputs in new transactions and also how transactions can be split and consolidated giving us forks and merges in the chain.}
  \label{fig:transaction}
\end{figure}


\subsection{Blockchain}

The double spending problem is that a user can spend the same value twice, in this case create two transactions, each spending the same output, and both will be valid as the user signed both with their private key; the transactions might be valid but should not be accepted as they spend the same output. To avoid ths in a peer-to-peer system nodes must have consensus about the transaction chain which should be public. The solution Nakamoto \cite{nakamoto2008bitcoin} proposed for creating a shared public transaction history without a central authority, is having nodes timestamp collections of transactions by hashing them together with the previous timestamp hash. 
 The structure containing the transactions at each timestamp is known as blocks, which are published to the network where each node stores their own copy. 
This process of timestamping blocks forms a chain because of the inclusion of the hash for the previous transaction collection, and thereby orders the transactions and proves their existence in relation to other transactions, also validating them futher than just the signature of the owner. A transaction included in a block is proven to have been confirmed by the network and seen as valid at a certain point and spends inputs found in transactions found in earlier blocks in the chain. If someone was to try and double spend an output they would not be able to because only one of the double spending transactions can be included in a block to maintain the integrity of the transaction chain, and if one them was included in a block and thus confirmed the other one will be seen as invalid by all nodes who have a copy of the blockchain and see that this output is already spent by the transaction included in a block. Thus the blockchain ensures consensus by nodes requiring new transactions to spend already confirmed and valid outputs found in a block, and enforcing a common transaction history.

\begin{figure}[h]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.7\textwidth]{figures/blockchain}
  \caption[Transaction chain]{A section of a example transaction chain. We see how outputs of previous transactions become inputs in new transactions and also how transactions can be split and consolidated giving us forks and merges in the chain.}
  \label{fig:blockchain}
\end{figure}

As new transactions are created they spread around in the network, are validated, and each one node collects them in a pool for transactions that have not yet been included in a block. Nodes try to create blocks by including transactions from the pool and trying to find a nonce to include in the block such that the hash of the block starts with a given number of zero bits. This process is called mining and in addition to awarding new Bitcoin to whoever finds the solution first it requires computational power to be expended for blocks to be created. This system is called proof-of-work because the brute forcing of the hash value requires work to solve; it is also easy for others to verify the solution when the new block is published. As the blockchain grows with more blocks, the total amount of computational resources used increases. This secures the blockchain as it bolsters the immutability of blocks as they get further back from the tip, meaning they will have a greater amount of spent resources on top of them in the chain. As the Bitcoin system is a distributed one, this mining process is how nodes get to vote on their shared transaction history.
To rewrite parts of the blockchain to change the transaction history an attacker would have to redo the work from that point and exceed the height of the current used blockchain. This is because the highest chain is considered the valid one as it has the more work put into it by the nodes. The incentive of new coins when finding a solution and creating a new block also makes spending computational power to change the blockchain instead of mining less desirable. 


\subsection{Transaction Scripts}

Bitcoin transactions use a stateless, stack based, non touring complete language called script \cite{antonopoulos2017mastering}.
The outputs of transactions are locked using script by placing requirements for spending the outputs; inputs contain scripts that meet the requirements placed by their respective output scripts. The language has a predefined set of operations that can be done called Opcodes which limits possibilities of scripts. 
An example of a common locking script placed in outputs is: 
\\

OP\_DUP OP\_HASH160 <receivers public key hash> OP\_EQUALVERIFY OP\_CHECKSIG
\\

This script is a Pay to public key hash (p2pkh) script because the sender can use this script lock the output to the receivers public key hash. The receiver can spend this output by supplying their <signature> <public key> in the input which will meet the requirements placed by the output script and unlock the founds. The unlocking script will be combined with the locking script and executed to ensure that it is valid. 
\\

<receivers signature> <receivers public key> OP\_DUP OP\_HASH160 <receivers public key hash> OP\_EQUALVERIFY OP\_CHECKSIG
\\

The goal of this script is to check if the <public key> in the unlocking part hashes to the <public key hash> of the locking part, and then if the <signature> in the unlocking part matches the public key.
When the script executes the execution pointer will move left to right pushing data to the stack and do the operations specified.
In the case of P2PKH scripts the <signature> will be moved to the stack followed by the <public key>, OP\_DUP duplicates the top item on the stack, in this case the <public key>. Then the OP\_HASH160 will hash the top item of the stack meaning the top <public key>. The <public key hash> given in the locking part of the script will then be pushed to the stack and OP\_EQUALVERIFY will compare the two top items which now are the <public key hash> and the the hash of the <public key> done by the OP\_HASH operation, if they are equal they are both removed from the stack. The final operations OP\_CHECKSIG takes the two last items on the stack <public key> and <signature> and checks them to see if the signature matches the public key which means it was created with the corresponding private key.

There are two "standard" transaction types commonly used; one being pay to public key hash (P2PKH) already described, and the other is pay to script hash (P2SH) \cite{BIP16}. While users are free to create any locking script they wish within the limits of scripts, these types are recognized by most wallet software and allows for senders to transfer value by locking it in known ways. With P2PKH the receiver can just send a hash of their public key and the sender can create the locking script outlined above and just insert the hash. Instead of a public key hash P2SH allows for the same process but with complex scripts by using a hash of the script. A complex script can be created, hashed, and the hash value is used for creating the locking script resulting in:
\\

HASH160 <script hash> EQUAL
\\

The unlocking script will contain the script that was used to create the hash as one stack item only. When this is executed the whole original script, known as the redeem script will be pushed to the stack, then hashed using OP\_HASH, the script hash from the unlocking script is then pushed to the stack, and finally the two hashes are compared.
\\

<redeem script> HASH160 <script hash> EQUAL
\\

This hashing and comparing will ensure that the script supplied must be the original one. After it is confirmed that the given script is the correct one, that script itself is executed to see if it evaluates to true. The conditions for the redeem script must also be satisfied meaning that potential signatures or other data must also be supplied in the input unlocking a output. This "standard" has two executions, one being to check if the redeem script given by the redeemer matches the hash in locking script, and then the redeem script itself is run.
One reason for this is to move the responsibility for supplying these script from sender to receiver. The receiver can create whatever script they wish without the need for the sender to recreate the script when forming the transaction and locking the output. The sender receives a hash of a script and can crate the standard P2SH locking script with the format given above. The receiver needs to know the script to unlock the output but the sender does not need to know the script to transfer value; it therefore makes sense to place the burden of supplying the redeem script on the receiver instead of the sender. A typical use case for P2SH is multisig scripts: 
\\

2 <public key 1> <public key 2> 2 OP\_CHECKMULTISIG
\\

These scripts require multiple signatures to be valid, meaning multiple key-pairs which implies users are required to spend a output.
In the case above two signatures is required for the two keys, indicated by the number 2 before the keys and the 2 after.
This will be the redeem script which is hashed and given to the sender which creates the P2SH locking script for this hash.
The sender does not need to know the public keys required to spend the output or that it is a multisig script in the first place. The receiver however, needs to know as they are the ones who will claim the value and most likely controls (one) of the public keys required in the redeem script.

\subsection{Segregated Witness}

Segregated Witness (segwit) is a change to mainly the Bitcoin consensus layer defined in Bitcoin improvement proposal (bip) 141 and 143 \cite{BIP141}\cite{BIP143}. It changes the structure of the validating data used to verify transactions and where it is stored. As mentioned transactions outputs have a locking script and a unlocking script; the witness is the unlocking script which can be used to check the validity of the output spent. Segwit places unlocking scripts in a witness data structure which is no longer stored inside the transaction it is used to validate. One of the reasons this is done is to fix transaction malleability, which is the ability to change the transaction id (txid) of a transaction. A txid is a hash of all the properties of a transaction including the unlocking script/witness. The only malleable parts of a transaction is the unlocking script, because a transaction is unique and outputs can only be spent once. So if the choice of inputs, choice of outputs, or the value of these changes, it is no longer the same transaction.
Therefore, when the transaction has been created most of it is non malleable, but the unlocking script can be modified in different ways without invalidating the transaction. Adding operations to the unlocking scripts or zero padding numbers used can achieve this effect and change the id while transaction is for all intents and purposes the same \cite{BIP62}. With segwit the txid hash will be calculated whiteout considering the witness data and therefore remove possibilities for malleability. Since the witness data is only used to validate the transaction itself, it is not necessary to determine the state of the blockchain and can therefore become optional for lightweight nodes saving bandwidth. 

Changes in the consensus mechanism within the Bitcoin network could cause the blockchain to fork. If one set of nodes upgrades their software containing other consensus rules they would only create blocks containing transactions following those rules. Similarly the nodes using the old rules will only consider the transactions matching their specifications. The blockchain will thus split from the point which they last agreed on in two different directions each containing their separate transaction history after the split. This is known as a hard fork because of the effects it has on the network and the blockchain. Segwit was designed to avoid this by being backwards compatible with non segwit nodes. Such a change is known as a soft fork since it does not cause a hard fork. Soft forks are easier to introduce to a decentralized network because it does not require a coordinated upgrade of software. A segwit transaction ouptut is constructed such that a non segwit enabled node will interpret the output as being spendable by everyone-i.e., reedemable by a empty signature; this means a non segwit node cannot correctly validate a segwit transaction but will not consider it invalid \cite{antonopoulos2017mastering}. 

Segwit has two "standard" transaction types which mirrors the functionality the existing ones: pay to witness public key hash (P2WPKH), and pay to witness script hash (P2WSH). The main change is how the locking scripts in the outputs is structured; instead of including the script in the output there are now only a version byte with the value 0 to 16 and then 20b bytes representing the public key hash if the output is P2WPKH or 32 bytes of a script hash if the output is P2WSH. Currently only version 0 is used with the rest being reserved for future versions \cite{BIP141}. It is the lenght of the bytes following the version bytes which decides which type of output the script is. A example of a P2WPKH locking script is:
\\

0 <20 byte public key hash>
\\

The unlocking script is found in the witness structure which is a stack containing the required data to validate the transaction.
In the case of the P2WPKH the witness stack will contain two elements: the <signature> and the <public key> which is the same required to validate the older P2PKH transaction type. In the case of the P2WSH type the witness stack can contain a varying amount of items depending on the requirements of the redeem script. If the redeem script is a mutlisig script the stack will contain the required amount of <signatures + public keys> with the last item of the stack always being the redeem script itself.

\subsection{Payment Channels}


The mechanisms for doing exchanges in the channel are simple themselves, but there are many problematic scenarios that can arise when doing off-chain.
A payment channel between Alice and Bob uses 2of2 multisignature Bitcoin transactions. A multisignature transaction means that multiple keys are required to spend a output of a transaction. A 2of2 multisignature means that 2 keys of a potential 2 keys are required-i.e., both Alice and Bob need to use their keys. This ensures that both sides agrees on transactions done with the founds in the channel. Without it, one of them could just create a new transaction spending all founds in the channel, publish it to the blockchain, and thereby stealing from the other.

\paragraph{}
To exchange founds in a channel one first needs to create whats is known as a "founding transaction" or "anchor transaction". Its purpose is to create a common starting point for the creation of new transactions in the channel. The input value of the founding transaction can come from one or both of the parties in the channel, but the output will have a 2of2 multisignature condition. Then a new transaction spending the output of the founding transaction is created which refund the input values of the founding transactions back to its original owners, also with a mutlisignature condition on its output. At this point no signatures for either the founding or refund-transaction has been exchanged, meaning neither of the parties can publish anything to the blockchain. The exchange of signatures is done in a specific order where first the refund transaction is signed by both sides, and only then are signatures exchanged for the founding transaction. The reason for this is to avoid the founds being stuck in the founding transaction because of the multisignature condition on its output. If the founding transaction where published without or before a refund transaction was created and signed, either Alice or Bob could render the founds unusable by not co-operating because of the multisignature condition. After the signatures for the founding transactions has been exchanged it is published to the blockchain. The starting point of the channel is now established; containing the total value available in the channel and also allowing for refunds initiated by either party by publishing the refund transaction.

The transactions describing the balance between Alice and Bob are called commitment transactions. Balance in the context of payment channels is how the total value of the channel will be split between the parties-e.g., the total value of the channel is 10 coins and the balance is 5 to Alice and 5 to Bob; Alice decides to send Bob 1 coin; now the balance is 4 coins to Alice and 6 to Bob; as shown in fig.\ref{fig:ln_commit} where we see the first commitment transaction on the left and the new on the right.

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{figures/ln_commit.png}
    \caption{The founding transaction is colored green to show it has been published to the blockchain. It has two commitment transactions. The leftmost is the original and the right shows the balance after Alice sends Bob 1 coin. Source: \cite{poon2015bitcoin}}
    \label{fig:ln_commit}
\end{figure}

The commitment transactions are all created from the output of the founding transaction just as the refund transaction was. The balance in the channel is described in the output of these transactions, so these commitment transactions takes the total value of the channel in the form of the output of the founding transaction and splits it between the parties in it's own output parameters. The refund transaction can be said to be the first commitment transaction since it describes the initial balance in the channel. This initial balance will be whatever each party contributed to the input of the founding transaction. When the balance in the channel needs to be updated a new commitment transaction is created spending the output of the founding transaction again. The exchanging of founds between Alice and Bob consists of them creating new commitment transactions each time an transfer is done, which represents the new balance between the two. Alice and Bob exchanges signatures for each newly created commitment transaction to satisfy the multisgnature condition, which enables any one of them can publish it to the blockchain at any time they wish. A transaction output can only be spent once, so when a commitment transaction is published the founding transaction is spent, and all other commitment transactions created are therefore useless. This means that the channel no longer has any uses, because its value or founding transaction is spent. So channels are closed out by publishing a transaction spending the output of the founding transaction. Therefore, to be able to do many transfers between the sides in the channel the commitment transactions should not be published immediately. Only when something goes wrong, or both/one of the parties wishes the channel to close should the newest commitment transaction representing the current balance be published to the blockchain. 

The payment channels should not require the parties to trust each other to be able to do exchanges.
As described earlier there are mechanisms that ensures co-operation, such as the refund transaction founding transaction signature order; which makes malicious behaviour such as rendering the founds unusable impossible. A mechanism is needed to solve the big problem of making sure only the newest commitment transaction which has the correct balance is published to the blockcain. Using the earlier example where a channel between Alice and Bob had the value of 10 coins and the balance was 5 to each of them. If Alice Does several payments to Bob and the balance ends up being 0 to Alice 10 to Bob, she could publish the commitment transaction where the balance was 5 to each and get all her money back. To deal with this problem it is proposed to penalize anyone who publishes any other commitment transaction than the latest. The penalty is that whoever published the old commitment transaction will loose all the founds to the other person in the channel.
In order to punish the party who published an old commitment transaction it must be clear which one of them did it; this is known as the problem of ascribing blame. When the two parties exchanges signatures for a commitment transaction we in reality end up with two different versions of the same transaction. Bob signs one and sends it to Alice, and Alice signs one and sends it to Bob. This means both sides ends up with a half signed transaction which only needs their own signature before it is published to the blockchain. The multisignature requirement for commitment transactions means that each side can only publish the one they received from the other.
E.g., if Bob is the one who published a commitment transaction we can find out, because he must publish one of those he received from Alice which already had her signature.

\paragraph{}
The mechanism to punish the party who published an old transaction consists of revoking old commitment transactions. This means each of the parties create a transaction spending their share of a old commitments, signs it and sends it to the opposite party as an insurance. If one side publishes the old commitment  the other will be able to spend the both outputs of the old commitment transactions. This, in combination of enforcing a time period where the person who publishes commitment transactions cannot spend their output, is how old commitments are revoked. So if Bob publishes an old commitment transaction Alice can spend Bobs output before he can do so himself because of the timeout.

\paragraph{}
The timeout of transaction outputs is done with Revocable Sequence Maturity Contracts (RSMC). When looking at the problem of ascribing blame there were two half signed copies of each commitment transaction; Bob got one where Alice has signed, and Alice one where Bob has signed. Both of them are could be published to the blockchain but only the first one will be valid, since they both spend the same output of the founding transaction. The timeout will be placed on the party who publishes the transaction; reason being to try and steal from the other one would publish a transaction themselves-e.g., Alice would publish a old transaction where the balance in the channel favors her and not Bob. For each set of commitment transactions each of them will have a RSMC on the output giving founds to the holder of the commitment transaction. The output which gives founds to the other party is not encumbered with this timeout. Fig.\ref{fig:ln_timeout} shows this structure with two sets of commitment transactions and their outputs. The timeout is enforced by confirmations of the commitment transaction. Confirmations is how deep a transaction is in the blockchain, so when a transaction is included in a block it has one confirmation, when another block is added to the chain it has two and so on\cite{antonopoulos2017mastering}. In the RSMC case it will make the person who publishes the commitment transaction unable to spend their output of that transaction until it has a set number of confirmations. In the paper they uses 1000 confirmations which will take some time when considering a 10 minute block interval.

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{figures/ln_timeout.png}
    \caption{Here we see a pair of commitment transactions for Alice and Bob and their outputs. Purple indicates that Alice can publish and blue shows that Bob can publish. Source: \cite{poon2015bitcoin}}
    \label{fig:ln_timeout}
\end{figure}

The need to wait for confirmations to spend the output is something that is enforced on every set of created commitment transactions. It enables the next step that allows for old commitment transactions to be revoked. Whenever a new set of commitment transactions are created both parties sign and exchange whats called a Breach Remedy Transaction. This spends the output that is confirmation locked for that person-e.g., Alice creates a breach remedy transaction spending her output in the old commitment transaction and sends it to Bob. Now if either of the two parties publishes a old commitment transaction, they cannot spend their output at once because of the RSMC, and the other can publish the breach remedy transaction and get their output in addition to their own. The only way one one of the parties can publish an old transaction and get away with it is if the other party does not publish the breach remedy transaction before the timeout is over. If enough time passes so that the commitment transaction gets enough confirmation the one who published it will be able to spend their output as long as the other party has not published the breach remedy transaction. Even so, the other party still would get their output.

\paragraph{}
Lets say Alice and Bob has a channel with the value of 1 coin where they both contributed 0.5 coins each. They create a funding transaction, a refund transaction (which is really the first pair of commitment transactions paying back 0.5 coins to each), sign the refund transaction and then the founding transaction. After the funding transaction is published the channel is ready as shown in fig.\ref{fig:ln_breach}. The current commitment transaction (C1a for Alice and C1b for Bob) have their two outputs giving each 0.5 coins, one normal (D1b and D1b) and one Revocable delivery (RD1a and RD1b) which needs confirmations to be broadcast. Then Alice sends Bob 0.1 coins. Bob creates his breach remedy (BR1b) which spends his 0.5 of the commitment transaction (C1b); this is the same 0.5 output that used in the Revocable delivery (RD1b).
Alice does the same thing and sends it to Bob. Now that the old commitment transactions (C1a and C1b) are revoked they can create the updated pair (C2a and C2b) witch the new balance which outputs 0.4 to Alice and 0.6 to Bob. Now Bob decides to broadcast the old commitment transaction (C1b) to the blockchain. A strange decision since in the old balance he has 0.1 coins less but it's still a violation of the agreement between the parties of not broadcasting old commitments. 
He cannot claim Output 1 of 0.5 coins since he must wait for 1000 confirmations to do so because of the Revocable delivery (RD1b).
Alice sees on the blockchain that an old commitment transaction has been published. She has access to output 0 of 0.5 coins at once since it was Bob who published and therefore there is no confirmation requirement for her. She also has the breach remedy transaction Bob sent her which spends output 1 of 0.5 coins. She can publish this before Bob because he has to wait for confirmations and thereby she gets both outputs and the total value of 1 coin.

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/ln_breach.png}
    \caption{This is what happens when an old commitment transaction is published. Green indicate that the transaction is published to the blockchain. We see two pairs of commitment transactions, with output transactions shown for the older pair. In this example Bob has published his old commitment transaction violating the agreement, therefore we see that Alice can publish transactions spending both outputs. Source: \cite{poon2015bitcoin}}
    \label{fig:ln_breach}
\end{figure}

\paragraph{}
Publishing a old commitment transaction as described above will spend the founding transaction and close the channel in addition to the other implications already described.
The channel can also be closed out by either of the parties publishing the most recent commitment transaction. If Bob was the one who published Alice can spend her output at once but Bob has to wait for confirmations in the blockchain before he can claim his. But still he will eventually get his output, and since no breach remedy transaction has been made because it is the newest commitment there is nothing Alice can do to stop him from getting his output.
However, the channel can also be cooperatively closed when both parties agrees to do so. They simply create new transaction spending the founding transaction with the outputs reflecting the balance in the latest commitment. They exchange signatures and it can be published on the blockchain. This transaction does not contain any Revocable delivery transaction on its output meaning both will be able to claim their founds at once. 
Another reason for doing this is that the total number of transactions that will be published to the blockchain will be less, one founding and one settlement, instead of the extra revocation transaction.

\section{Networked Payment Channels}

The payment channels discussed in the previous section are for two parties to exchange founds with each other.
As mentioned earlier the LN as described in the paper by Poon and Dryja \cite{poon2015bitcoin} consists of many such channels, forming a network. This means that a user can use this network send founds to others across several payment channels. If everyone needed to create a payment channel with everyone else it would not be very useful, so therefore there are mechanisms such that payments can be routed using other peoples payment channels. Lets say Alice and Bob has a payment channel, but Bob and Dave also has one. Alice wishes to send founds to Dave, and she can do so by sending it first trough her existing channel with Bob, and Bob can use his channel with Dave to deliver him the payment.

As shown in the previous chapter a payment channels used in the lighting network does not require trust between the two parties in the channel. The same should be the case for doing payments across channels without trusting the intermediary nodes along the path. The construction that enables this is called Hashed Timelock Contracts (HTLC).
It works by creating contracts where intermediary nodes have a guarantee that they can get their money from the sender, if they first transfer to the receiver. By having the intermediary first pay the receiver and then get money from the sender one stops the intermediary nodes from stealing the founds. If the intermediary was sent the founds first by the sender they could simply not pay the receiver and keep the founds. But for the intermediary nodes to accept this they need to be sure that the sender will pay them what they have already given the receiver. Using a hash function with an input or preimage R this guarantee can be crated. The receiver inputs R into the function and gets a hash H which is given to the sender. The sender promises to pay the intermediary if they can give R that generates H. The intermediary then promises to pay the receiver if they can provide a R that generates H. Since it was the receiver who created H and therefore has R they can give it to the intermediary and get the founds from them. Now the intermediary knows R and get the founds from the sender as promised.

\paragraph{}
The promise to pay someone in exchange for disclosing R is not only a promise. It is a transaction which needs R to be valid. Therefore when the sender promises to pay the intermediary the sender is no longer in possession of the founds. So the founds are effectively transferred in a manner and direction one would expect (sender, intermediary, receiver) but requires R to be claimed. The timelock is what ensures that if no R is provided the founds can be returned to the one who promised them. It basically ensures delivery of the founds by setting a deadline on providing R. If no such thing existed the series of exchanges could be delayed or stopped by nodes not disclosing R and claiming their founds.
Using an example and figures \ref{fig:htlc_promise} and \ref{fig:htlc_settle} illustrating we can see how this works in detail.
Alice wishes to send founds to Dave, but to do so she must first send them through Bob and Carol. Dave the reciver is the one who creates the hash H with the preimage R and sends H to Alice. She sees that there are tree hops for the founds to reach Dave, so she creates the first HTLC with a three day timelock and sends it to Bob shown as step 1 in fig.\ref{fig:htlc_promise}. To re-iterate the HTLC is a transaction where the preimage R has to be given for the founds to be claimed, if R is not given within the timelock timeframe (three days in this case) the founds can be reclaimed by the creator of the HTLC. Bob creates a new HTLC for Carol with the same condition except that the timelock is two days shown as step 2 in fig.\ref{fig:htlc_promise}. In step 3 Carol creates a HTLC for Dave with the timelock set to one day. At this point the founds have been sent but no one has claimed the founds from the HTLC's so the payment is not complete. If Dave does not disclose R and claim the founds from the HTLC he received it will time out, and so will the other HTLC's.

\begin{figure}[h]
    \centering
    \includegraphics[width=11cm]{figures/htlc_promise.png}
    \caption{ Creating a HTLC between each node with a decrementing timelock. Source: \cite{poon2015bitcoin}}
    \label{fig:htlc_promise}
\end{figure}

In fig.\ref{fig:htlc_settle} we see how the payment is completed with steps 4, 5 and 6 done. Since it is Dave who knows R he must start the process. In step 4 he reveals R to Carol to claim the founds in their HTLC. Carol can then do the same with Bob in step 5, and finally step 6 where Bob can pull his founds from Alice.
Now the founds have been fully transferred from Alice to Dave.
The reason that the timelock must be shorter the closer we get to the final receiver of the founds is because it ensures that each person has time to pull the founds from the preceding one. Lets say that step 3 in fig.\ref{fig:htlc_promise} had a timelock of 5 days, and Dave waited 4 days to disclose R to Carol and get founds from her. The HTLC from Bob to Carol would have expired by then and Bob would have reclaimed his founds, meaning Carol has lost her founds to Dave without any way of getting them back.

\begin{figure}[h]
    \centering
    \includegraphics[width=11cm]{figures/htlc_settle.png}
    \caption{ Founds are pulled in reverse order meaning Dave the receiver gets the founds first and the sender Alice looses her's last. Source: \cite{poon2015bitcoin}}
    \label{fig:htlc_settle}
\end{figure}


\section{HTLC inside the payment channel}
The previous section explained how HTLC's can be used to transfer founds across different payment channels.
Here we will show how the HTLC construct interact with the already established dynamic within a payment channel.
A HTLC inside a payment channel will be a output of commitment transactions. Outputs of these commitment transactions reflects the balance between the parties inside the channel, so by having another output we can also reflect founds in transit. The HTLC output is a special type of output; it is a output script which has two different paths to redeeming the output: one is by providing the preimage R, and the other is by waiting for the timelock to expire. As with other output it can only be spent once, and this type must be spent in one of the two ways explained.

\paragraph{}
As an output of commitment transaction the HTLC uses founds available in the channel. If the value of a channel is 10 coins with a 5 to each split, a HTLC for 1 coin will be reflected in the commitment transaction as the sender having only 4 coins, but the total value of the channel will still be 10 (4 sender, 1 HTLC, and 5 receiver). If they both agree on who can spend the HTLC output-e.g., receiver knows the preimage R they can spend. or the timelock is over the sender can spend it, then they can cancel the HTLC and create a new commitment transaction reflecting the new balance. This new balance is either the receiver getting the value of the HTLC or the sender getting it back. This is how HTLC's are resolved off-chain.

\paragraph{}
The two ways of spending a HTLC output is by creating a "delivery" transaction which needs the preimage R to be valid or creating the "timeout" transaction which is not valid until the timelock is gone. If they fulfill their conditions both of these can be broadcast to the blockchain. But since the these transactions spend a output of a commitment transaction the commitment transaction would also need to be broadcast on the blockchain to be able to spend its outputs in new transactions. As explained earlier both parties have the opportunity to broadcast their commitment transaction but restrictions will apply when doing so. The one who published a commitment transaction had to wait before being able to claim their output, while the other party could claim theirs at once. In addition, if the commitment transaction was old and had been revoked by the creation of a superseding transaction spending the
broadcasters output (Breach Remedy Transaction), the other party could use this to get all the founds since the broadcaster had to wait to spend their output.
The same mechanism is used when adding the third HTLC output on the commitment transactions. Using the example of Alice and Bob having a 1 coin channel with a 0.5 to each balance we can see how this works. Alice sends Bob 0.1 coins using a HTLC and they create a new pair of commitment transactions (C2a, C2b) as shown in fig.\ref{fig:htlc_commit} where Alice can broadcast the purple ones and Bob the blue.


\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/ln_htlc.png}
    \caption{ Overview of transactions when including HTLC output to the commitment transactions. Again we have a mirrored structure with the left side showing the case of Alice broadcasting the commitment and the right side Bob broadcasting.  Source: \cite{poon2015bitcoin}}
    \label{fig:htlc_commit}
\end{figure}


\paragraph{}
If the sender, in this case Alice is the one who broadcasts her commitment transaction (C2a) she will have the restrictions placed on her.
In fig.\ref{fig:htlc_commit} this means that the left side will be executed. The commitment transaction (C2a) has three outputs: output 0 is 0.4 to Alice herself (RD2a), but since it is her commitment transaction she will have to wait for confirmations to be able to spend; output 1 is 0.5 for Bob, which he can spend immediately (D2a); output 2 is the HTLC which has two different output paths, Bob can spend at once creating a transaction containing the preimage R (HED1a), or Alice can spend (HT1a) when the timelock has expired but this spend will have a RSMC (HTRD1a) having her wait for confirmations similarly as her normal output (RD2a). This is because similarly as old commitment transactions are invalidated by exchanging breach remedy transactions the same is done by exchanging keys for spending the HTLC output. So if an old commitment transaction is broadcast the party who broadcast will also loose the HTLC output in addition to the normal output, since the other party will be able to spend it and broadcast to the blockchain before the RSMC has enough confirmations. In this case it will enable Bob to broadcast a transaction spending the value of the HTLC before Alice can.

\paragraph{}
In the case of Bob, the receiver broadcasting the commitment transction (C2b), the left side of fig.\ref{fig:htlc_commit} will be executed. We can see that the structure is the same but now Alice and Bob have different restrictions. The output of the commitment transaction remains the same except that now it is Bob who has to wait for confirmations to get his normal output of 0.5 because of the RSMC (RD2b), and Alice can spend hers at once (D2b). In the case of the HTLC output the two parties still have their sender and receiver status meaning Alice can only spend by Timeout of the timelock (HTD1b), and Bob only by providing the preimage R (HE1b). However, since it now was Bob who broadcasted the commitment he is the one who has to get restricted getting the output by waiting for confirmations. So the output of the transaction spending the HTLC output using R (HE1b) is now a RSMC (HERD1b) which will require confirmations to become valid. This is to once again enable the other party (Alice) to get the value in the HTLC if the commitment transaction was an old one.  

\paragraph{}
Similarly as with channel operation without HTLC it is desirable to avoid publishing to the blockchain unless it is necessary. The parties can cooperate and agree on new commitment transactions with or without HTLC outputs. To resolve a HTLC one of the parties must simply prove to the other that they are capable of spending the HTLC output and can do so on the blockchain if they wish. If Bob is the receiver he can publish the commitment transaction and if he has the preimage R he can also create a transaction spending this; because he is the broadcaster he must wait for confirmations on both but will eventually receive his founds. If Bob does not have the preimage R and the timelock has expired Alice can do the same. Since they can prove to the other party that they have this possibility they can instead just create a new commitment transaction pair with the HTLC value either transferred to Bob or returned to Alice, thereby keeping  commitment transactions off-chain and have the channel remain open. When doing this they need to invalidate their old commitment transactions and also the HTLC output of these by exchanging breach remedy transactions and keys. So again we have a system for exchanges between two parties but with the possibility of also using HTLC's which requires no trust, few transactions to be broadcast to the blockchain unless one party is unresponsive or unwilling to co-operate, and allows for founds to be transferred trough many channels.  
When using the HTLC construct to send founds across these channels as shown in fig.\ref{fig:htlc_settle} broadcasting to the blockchain as discussed in this section will ensure the transfer will finish in the event of a node not co-operating as illustrated in fig.\ref{fig:htlc_bc}.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{figures/htlc_bc.png}
    \caption{ Settlement of HTLC contracts in the event of unresponsive node using the blockchain. Source: \cite{poon2015bitcoin}}
    \label{fig:htlc_bc}
\end{figure}