\chapter{Background and Related Work}
\label{chap:related}

\section{Background}
\label{sec:background}

This section covers the background required for Bitcoin and the Lightning Network. Both systems are large and rely on many mechanisms to operate, so we will only cover the main elements and those relevant to this thesis.

\subsection{Transactions}
\label{subsec:transactions}

Transactions are the mechanism of transferring value between users in the Bitcoin system, but they are also the value themselves.
The coins in Bitcoin are more of an abstraction, which we can see clearly from the definition of a coin in the white-paper: "We define a coin as a chain of digital signatures"~\cite{nakamoto2008bitcoin}.
Transactions are basically such a chain of digital signatures, so owning "coins" really means controlling transactions, which have a value.
Public key cryptography is used to sign transactions and to transfer ownership of value; meaning a transaction is tied to or owned by a public-private key pair.
To transfer control of a transaction and therefore its value to another entity, the owner locks the transaction using the public key of the recipient, and then uses their own private key to generate a signature showing that the transfer was done by the now previous owner of the transaction. The cryptographic lock placed on the transaction by the previous owner, makes the recipient in control of the transaction, as they control the private key paired with the public one used to lock the transaction. Everyone else  can verify this transfer, because the previous owner generated the signature using their private key when locking the transaction to a new public key, and therefore showing that they had control of the key pair controlling the transaction at the time of the transfer. The transaction as a data-structure, represents one transfer of value, meaning for each transfer a new transaction is created. This results in a series of transactions, each representing a change in control of the value, and these will be related to each other as they contain the same value, but represents different transfers. This is the chain of signatures (transactions) we introduced at the start of this section. By following the chain of transactions and verifying the cryptographic signatures in each transaction, everyone can verify the current ownership of the value. Only the newest transaction in the chain can transfer the value to another key pair, as previous transactions in the chain are only historical states, allowing for the current state to be verified. This transaction chain have the ability to fork and merge, enabling the value to be split into different transactions, or merge the value of many into a single transaction. Therefore the structure is not a linear chain, but a directed acyclic graph (DAG), as no transactions can be spent twice.
With the possibility of splitting the value in a transaction, it no longer makes any sense for a single key pair to control the entire value of a transaction. Instead we should define value ownership in terms of controlling transaction outputs, which together with transaction inputs are the two main parts of a transactions. In short: outputs is the link forward in the transaction chain, while the input is the link backwards. The output of a transaction is where the creator of the transaction locks the value to a public key, and with multiple outputs can give different keys control of different outputs, each with a portion of the value of the transaction. The input of transactions, is the output of previous transactions in the chain, indicating which value the transaction transfers. \Cref{fig:transaction_graph} depicts a small part of a transaction graph with outputs and inputs connecting transactions and transferring control of value. The transaction graph contains all information about how value has been transferred, and as mentioned earlier: only the newest transactions shows current ownership of value, so the leaf nodes in the graph represents the current owners of the value.
This graph structure means that the value of a transaction must be used in its entirety when transferring it, or it will be lost, as its transaction is no longer a leaf node. If the creator of a transaction does not wish to transfer the entire value to another entity, they can transfer it back to themselves. This is done by creating a output and locking it to their own public key. Similarly, if a user has no output with sufficiently large value wanted for a transfer, they can use multiple outputs for inputs to the transaction, and by doing so will reach the desired value of the transaction, which an example of can be seen in the right upper transaction in~\cref{fig:transaction_graph}.


\begin{figure}[h]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.7\textwidth]{figures/transaction}
  \caption{Section of a transaction graph}
  \label{fig:transaction_graph}
\end{figure}


\subsection{Blockchain}
\label{subsec:blockchain}

The double spending problem is that a user can spend the same value twice; in this case create two transactions transferring the value to different users, each transaction spending the same output, and both will be valid as the sender signed both with their private key. To avoid this problem one can have a central authority approving transactions, or in a peer-to-peer system like Bitcoin, create consensus by maintaining a public data-structure containing all transactions. The solution Nakamoto~\cite{nakamoto2008bitcoin} proposed for creating a shared public transaction history without a central authority, is having nodes timestamp collections of transactions by hashing them together with the previous timestamp hash. This is necessary as it makes everyone agree on the state of the transaction history at a given time, which again is used as the basis for the next agreement. If there was no such consensus mechanism, several different transaction histories could be spread within the network and nodes could not determine which one to trust.
The structure containing the timestamped collection of transactions is known as blocks, which when created is spread in the network where each node stores a copy. 
This process of timestamping blocks forms a chain because the inclusion of the hash form the previous block, which also makes the current consensus build upon the previous agreements of the transactions history. This chain of blocks containing timestamped transactions which provides a incrementally created shared history can be seen in \cref{fig:blockchain}. When a transaction is included in a block, it is proven to have been verified by the network and is confirmed to have taken place, since it is part of the shared history, and it can therefore be accepted as a payment. If someone wants to double spend an output they would not be able to, because only one of the "double spending transactions" would be included in a block. Reason for this is that the transaction graph would not allow spending the same output in two different transactions, and a single shared transactions graph is ensured with the blockchain, so there would not be two versions of this graph each using a different transaction for the same output. The transaction graph is used to transfer control of value between key pairs, and ensuring that this flow of value is valid; the blockchian ensures that there is consensus in the network about the history of this transaction graph.
\\

\begin{figure}[h]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.7\textwidth]{figures/blockchain}
  \caption{The structure of the blockchain}
  \label{fig:blockchain}
\end{figure}

As new transactions are created and propagated trough the network, each one node collects them in a pool containing transactions that have not yet been included in a block. Nodes try to create blocks with transactions from this pool by finding a nonce to include in the block, such that the hash of the block starts with a given number of zero bits. This process is called mining; in addition to awarding new Bitcoin to whoever finds the solution first, it also requires computational power to be expended for the hashing. This is called proof-of-work because the solution can be easily verifiable by checking if the nonce produces the given hash, but to find the solution in the first place requires substantial work. As the blockchain grows with more blocks, the total amount of computational resources used also increases. This secures the blockchain as it increases the practical immutability of blocks as they get further back from the tip, meaning they will have a greater amount of spent resources on top of them in the chain. The Bitcoin system is a distributed one, so the mining process is the method used to by nodes to create their shared transaction history.
To rewrite parts of the blockchain and change the transaction history, an attacker would have to redo the work from that point and exceed the height of the current used blockchain. This is because the highest chain is considered the valid one as it has the more work put into it by the nodes. Assuming the majority of the nodes in the system is honest and works towards the "correct" chain, the scenario to create another chain exceeding the current becomes unlikely and very expensive in terms of work required. There is also incentive of new coins when creating a a new block, so spending computational power to change history in the blockchain instead of mining coins for the current one would be wasteful. 


\subsection{Transaction Scripts}
\label{subsec:scripts}

Bitcoin transactions use a stateless, stack based, non touring complete language called script~\cite{antonopoulos2017mastering}.
The outputs of transactions are locked using scripts, which place requirements for spending the outputs; inputs contain scripts that meet the requirements placed by their respective output scripts. The language has a predefined set of operations that can be done, called Opcodes, which limits the possibilities of scripts. 
An example of a common locking script placed in outputs are: 

\begin{verbatim}
   OP_DUP OP_HASH160 <receivers public key hash> OP_EQUALVERIFY OP_CHECKSIG
\end{verbatim}


This script is a pay to public key hash ({\tt P2PKH}) script because the sender can use this script to lock the output to the receivers public key hash. The receiver can spend this output by supplying their {\tt<signature> <public key>} in the input, which will meet the requirements placed by the output script and unlock the founds. The unlocking script will be combined with the locking script and executed to ensure that it is valid. 

\begin{verbatim}
   <receivers signature> <receivers public key> OP_DUP OP_HASH160 
           <receivers public key hash> OP_EQUALVERIFY OP_CHECKSIG
\end{verbatim}

The goal of this script is to check if the {\tt <public key>} in the unlocking part hashes to the {\tt  <public key hash>} of the locking part, and then if the {\tt <signature>} in the unlocking part matches the public key.
When the script executes, the execution pointer will move left to right pushing data to the stack and do the operations specified.
In the case of {\tt P2PKH} scripts, the {\tt <signature>} will be moved to the stack followed by the {\tt <public key>}, {\tt OP\_DUP} duplicates the top item on the stack, in this case the {\tt <public key>}. Then the {\tt OP\_HASH160} will hash the top item on the stack, which is the top {\tt <public key>}. The {\tt <public key hash>} given in the locking part of the script will then be pushed to the stack and {\tt OP\_EQUALVERIFY} will compare the two top items, which now are the {\tt <public key hash>} and the the hash of the {\tt <public key>} created by the {\tt OP\_HASH} operation previously, if they are equal they are both removed from the stack. The final operation {\tt OP\_CHECKSIG} takes the two last items on the stack: {\tt <public key>} and {\tt <signature>} and checks if the signature matches the public key, which means it was created with the corresponding private key.
\\

There are two "standard" transaction types commonly used: one being the pay to public key hash ({\tt P2PKH}) already described, and the other is pay to script hash ({\tt P2SH})~\cite{BIP16}. While users are free to create any locking script they wish within the limits of the language, these types are recognized by most wallet software and allow for senders to transfer value by locking it in known ways. With {\tt P2PKH} the receiver can just send a hash of their public key, and the sender can create the locking script as outlined above and just insert the hash. {\tt P2SH} transactions allows for the same process, but using the hash of a script instead of the hash of a public key. This allows for complex scripts to be created, hashed, and the hash value is then used for creating the locking script, resulting in:

\begin{verbatim}
   HASH160 <script hash> EQUAL
\end{verbatim}

The unlocking script will contain the script that was used to create the hash as one stack item only. When this is executed the whole original script, known as the redeem script, will be pushed to the stack, and then hashed using {\tt OP\_HASH}. Then the script hash from the unlocking script is pushed to the stack, and finally the two hashes are compared. The unlocking and locking script for this is shown below:

\begin{verbatim}
   <redeem script> HASH160 <script hash> EQUAL
\end{verbatim}

This hashing and comparison will ensure that the script supplied is the original one. After it is confirmed in the manner explained above, the redeem script itself is executed to see if it evaluates to true. The conditions for the redeem script must also be satisfied meaning that potential signatures or other data must also be supplied in the input unlocking a output. We can therefore say that that {\tt P2SH} has two executions, one being to check if the redeem script given by the redeemer matches the hash in locking script as previously explained, and then the redeem script itself is executed.
One reason for this is to move the responsibility for supplying these script from sender to receiver. The receiver can create whatever script they wish without the need for the sender to recreate the script when forming the transaction and locking the output. The sender receives a hash of a script and can crate the standard {\tt P2SH} locking script with the format given above. The receiver needs to know the script to unlock the output, but the sender does not need to know the script to transfer value; it therefore makes sense to place the burden of supplying the redeem script on the receiver instead of the sender. A typical use case for {\tt P2SH}, is multisig redeem scripts: 

\begin{verbatim}
   2 <public key 1> <public key 2> 2 OP_CHECKMULTISIG
\end{verbatim}

These scripts require multiple signatures and therefore multiple key-pairs to be valid, which implies multiple users are required to spend a output.
In the case above two signatures is required for the two keys, indicated by the number 2 before the keys and the 2 after.
This will be the redeem script which is hashed and given to the sender for them to create the {\tt P2SH} locking script with this hash.
The sender does not need to know the public keys required to spend the output or that it is a multisig script in the first place. The receiver however, needs to know as they are the ones who will claim the value and will therefore likely control at least one of the public keys required in the redeem script.
\\

As we have explained, public-private key pairs are used when transferring  control of the value represented by a transaction output, by creating new transactions and locking their outputs to the public keys (or a script with a key) of the receiver. Bitcoin address is an abstraction of this concept. In the {\tt P2PKH} transctions discussed above, a hash of the public key is used when creating the locking script; address is a base-58 encoded public key hash which is easier to use than a public key hash directly~\cite{antonopoulos2017mastering}. Reason for this is that base-58 does not contain letters and numbers which can be easily confused, for example, number zero $0$ and capital letter $O$. It also has a prefix denoting if it is a {\tt P2PKH} or {\tt P2SH} address, and a checksum at the end which can detect some common errors in the address.

\subsection{Segregated Witness}
\label{subsec:segwit}

Segregated Witness (segwit) is a change to mainly the Bitcoin consensus layer defined in Bitcoin improvement proposal (bip) 141 and 143~\cite{BIP141,BIP143}. It changes the structure of the validating data used to verify transactions and where this data is stored. As mentioned, transactions outputs have a locking script and a unlocking script; the witness is the unlocking script, which enables us to check the validity of the output spent by using it with the locking script. Segwit places the witness or unlocking script in a witness data structure which is no longer stored inside the transaction it is used to validate. One of the main reasons this is done is to fix transaction malleability, which is the ability to change the transaction id of a transaction. This id is a hash of all the properties of a transaction including the unlocking script/witness. The only malleable parts of a transaction is the unlocking script, because a transaction is unique and outputs can only be spent once-i.e., if the choice of inputs, choice of outputs, or the value of these changes, it is no longer the same transaction.
Therefore, when the transaction has been created most of it is non malleable, but the unlocking script can be modified in different ways without invalidating the transaction. Adding operations to the unlocking scripts or zero padding the numbers used can achieve this effect, and thus change the id, while transaction is for all intents and purposes the same~\cite{BIP62}. With segwit, the transaction hash will be calculated without the witness data, and therefore remove possibilities for malleability. As the witness data is only used to validate the transaction itself, it is not necessary to determine the state of the blockchain and can therefore become optional for lightweight nodes wishing to save bandwidth. 
\\

Changes in the consensus mechanism within the Bitcoin network could cause the blockchain to fork. If one set of nodes upgrades their software having other consensus rules, they would only create blocks containing transactions following those rules. Similarly the nodes using the old rules will only use the transactions matching their specifications. The blockchain will therefore split from the point which they last agreed on, resulting in two different directions each containing their separate transaction history. This is known as a hard fork because of the effects it has on the network and the blockchain. Segwit was designed to avoid this by being backwards compatible with non segwit nodes. Such a change is known as a soft fork since it does not cause a hard fork. Soft forks are easier to introduce to a decentralized network because it does not require a coordinated upgrade of software. A segwit transaction ouptut is constructed such that a non segwit enabled node will interpret the output as being spendable by everyone-i.e., reedemable by a empty signature; this means a non segwit node cannot correctly validate a segwit transaction but will not consider it invalid~\cite{antonopoulos2017mastering}. 
\\

Segwit has two "standard" transaction types which mirrors the functionality of the existing ones discussed in \cref{subsec:scripts}: pay to witness public key hash ({\tt P2WPKH}), and pay to witness script hash ({\tt P2WSH}). The main change is how the locking scripts in the outputs is structured; instead of including the script in the output, there is only a version byte with the value 0 to 16 followed by a 20 bytes containing a public key hash, or 32 bytes containing a script hash. The amount bytes found after the version byte allows us to determine if the output is a {\tt P2WPKH} or {\tt P2WSH}. Currently, only version 0 is used with the rest being reserved for future versions~\cite{BIP141}. An example of a {\tt P2WPKH} locking script is:

\begin{verbatim}
0 <20 byte public key hash>
\end{verbatim}

The unlocking script is found in the witness structure which is a stack containing the required data to validate the transaction.
In the case of the {\tt P2WPKH} the witness stack will contain two elements: the {\tt <signature>} and the {\tt <public key>} which is the same things required to validate the old {\tt P2PKH} transaction type. In the case of the {\tt P2WSH} type, the witness stack can contain a varying amount of items depending on the requirements of the redeem script. If the redeem script is a mutlisig script the stack will contain the required amount of signatures, with the last item of the stack always being the redeem script itself.

\subsection{Payment Channels in the Lightning Network} 
\label{subsec:pcln}

The structure and function of the Payment as channels explained in this section will be as they are described in the lightning network paper by Poon and Dryja~\cite{poon2015bitcoin}. A payment channel allows for two people to connect and transfer founds between themselves. By many users creating channels with each other, a network of channels is formed, which we will discuss in detail in \cref{subsec:networkpcln}. Here we will focus on how a channel allows for two people to transact in a trustless manner. The payment channels use Bitcoin transactions both for managing the channels, and to send founds inside the channel. But not all of them will be broadcast to the Bitcoin network, and therefore not included in the blockchain. At a high level, the channel is used by the two participants to keep track of how founds is distributed between themselves. This means that the channel has a balance showing how much founds each of the two participants has. The balance is updated as founds is sent between them. This is the basic premise of payment channels: when two people sends founds between themselves, it should not be necessary to broadcast each transfer, instead only the final result. E.g., Alice and Bob have a channel with a value of one coin, with the initial distribution being 0.5 to each; Alice sends Bob 0.1 coins in three separate transactions, resulting in a final distribution of 0.2 to Alice and 0.8 to Bob; this result is broadcast while the three 0.1 transactions are not. 
Using the example above we can see that only publishing the result requires one transaction to be broadcast, in comparison to three transactions if all intermediary transactions were broadcast.
The transactions that are broadcast we refer to as on-chain transactions, since they will be included in the blockchain. Off-chain transactions are the intermediary transactions not broadcast, and therefore not found on the blockchain.
While payment channels allow for multiple transactions to be done off-chain, they do require some on-chain transactions for managing the channels. One of these on-chain transactions are the founding transaction, which is used to create the channel and make a common starting point for the users in the channel. The founding transaction will contain a output locked using a multisig script, which we discussed in \cref{subsec:scripts}. The multisig redeem script used for the output creating the channel has the form~\cite{bolt3}:

\begin{verbatim}
2 <public key 1> <public key 2> 2 OP_CHECKMULTISIG
\end{verbatim}

Multisig script requires multiple signatures from different keys to be spent. The script above is a 2of2 multisig script when we denote it in the form of $n$ of $m$, where the number $n$ is the required and $m$ is the potential number of keys. Using 2of2 mutlisig scripts for the payment channel output in the founding transaction means that both parties in the channel must sign the transaction to spend it. This collectively controlled output in the founding transaction located on the blockchain, is the starting point of their channel, enabling them to do off-chain transactions. But to avoid the value of the channel being stuck in the founding transaction because one or both parties are uncooperative, as spending it the output on-chain requires both signatures, a new transaction is created with both signatures, spending the output and refunding the value. This is done before the founding transaction is published, such that either party have the ability to close out the channel by publishing the refund transaction. The process of setting up a channel starts with the parties creating a founding transaction with a 2of2 multisig output, but they will not exchange signatures for this transaction before they have created the refund transaction. The exchange of signatures is done in a specific order where first the refund transaction is signed by both sides, and only then are signatures exchanged for the founding transaction, and it is then published to the blockchain. The channel has now been established in a trustless manner, and it also allows for refunds initiated by either party by publishing the refund transaction and closing the channel. 
\\

The off-chain transactions done between the parties inside the channel is known as commitment transactions. 
They contain the current distribution or balance in the channel, which is how the total value of the channel will be split between the parties. Each time a transfer is done inside the channel a new commitment transaction is created reflecting the new balance between the two parties. E.g., the total value of the channel is 10 coins and the balance is 5 to Alice and 5 to Bob, which is reflected in the most recent commitment transaction; Alice decides to send Bob 1 coin; now the balance is 4 coins to Alice and 6 to Bob and a new commitment transaction is created to reflect this change. This is shown in \cref{fig:ln_commit} where we see the first commitment transaction on the left, and the new on the right which reflects the transfer from Alice to Bob used in the example. We can also see that commitment transactions are created from the output of the founding transaction just as the refund transaction was. The balance in the channel is reflected in the outputs of the commitment transactions-i.e., there will a output for each of the parties in the channel with the their portion of the total value.
The refund transaction can be said to be the first commitment transaction since it describes the initial balance in the channel. This initial balance will be whatever each party contributed to the input of the founding transaction. 
When the balance in the channel needs to be updated a new commitment transaction is created, which spends the output of the founding transaction again. While it is not possible to spend output twice, the commitment transactions has not been published, so the output is not really spent. Off-chain transaction consists of creating new commitment transactions for each transfer, reflecting the new balance in the channel.

\begin{figure}[ht]
    \centering
    \includegraphics[width=12cm]{figures/ln_commit.png}
    \caption{Commitment transactions. Source:~\cite{poon2015bitcoin}}
    \label{fig:ln_commit}
\end{figure}

Alice and Bob exchanges signatures for each newly created commitment transaction. This is satisfy the multisignature condition on the founding transaction output used in the channel, allowing any one of them to publish the commitment transaction to the blockchain at any time if they wish. As a transaction output can only be spent once, so any commitment transaction published to the blockchain will spend the founding transaction, making any other commitment transaction now invalid and unspendable. This will also close the channel, meaning it can no longer can be used, because its founding transaction is spent. Channels are closed out by publishing a transaction spending the output of the founding transaction. Therefore, to be able to do many transfers between the parties in the channel the commitment transactions should ideally not be published immediately. Only when something goes wrong, or both/one of the parties wishes the channel to close, should the newest commitment transaction representing the current balance be published to the blockchain, and thereby closing out the channel and distributing the value. This results in only two on-chain transactions: the founding and closing transaction, with a potential of many off-chain commitment transactions being done in-between.
\\

As the payment channels should be trust-less, there is mechanisms that ensures cooperation-e.g., the refund transaction and founding transaction signing order, which makes locking the founds used in the channel impossible. 
With the newest commitment transactions reflecting current balance in the channel, older ones will contain a different and therefore wrong balance, and should therefore not be published.
Using the earlier example where a channel between Alice and Bob had the value of 10 coins and the balance was 5 to each of them. If Alice Does several payments to Bob and the balance ends up being 0 to Alice 10 to Bob, she could publish the commitment transaction where the balance was 5 to each and get all her money back. To deal with this problem the there is a penalty to anyone who publishes any other commitment transaction than the latest. The penalty is that whoever published the old commitment transaction will loose all the founds to the other person in the channel.
Since both has the ability to publish a old commitment transaction, we must determine which of the two published; this is described in the Lightning paper as the problem of ascribing blame~\cite{poon2015bitcoin}. When the two parties exchanges signatures for a commitment transaction, 
we end up getting two different versions of the same transaction. Bob signs one and sends it to Alice, and Alice signs one and sends it to Bob. This means both sides ends up with a half signed transaction which only needs their own signature before it is valid and can be published to the blockchain. The multisignature requirement means that each of them can only publish the one they received from the other.
E.g., if Bob is the one who published a commitment transaction we can find out, because he must publish one of those he received from Alice containing her signature. As each side receives their version of the commitment transactions from the opposing party, the opposing party can create a insurance clause on the output to the party receiving the commitment. This means that when Bob signs a commitment transaction for sending to Alice, he can crate place a insurance clause on the output for Alice, punishing her if the commitment is published when it is outdated and vice versa.
This means that the commitment transactions for the two parties is not exactly the same, because they will contain this insurance mechanism, but the transaction pair will still have the same balance, spending the same outputs and have the same outputs, but with the addition of this insurance.
\\

The mechanism to punish the party who publishes an old commitment transaction consists of timelocking their output for a some period of time, meaning they cannot spend it immediately, while also allowing for the the other party to spend that output. 
This will result in one party getting all the founds in the channel if the other published an old commitment. The timelock of the transaction outputs is done with Revocable Sequence Maturity Contracts (RSMC). 
The timeout will be placed on the output to the party who publihes a commitment transaction. The reason for this is that the publisher would try to steal value by publishing a commitment transactions where the value favoured them compared to the most recent commitment. 
For each set of commitment transactions each of them will have a timelock/RSMC on the output giving founds to the holder of the commitment transaction. This means that parties can only publish commitment transactions with timelocks on their own oututs.
The output which gives founds to the other party is not encumbered with this timeout, since one would not publish a old commitment transaction where the balance favors the other. 
\cref{fig:ln_timeout} shows this structure with two sets of commitment transactions and their outputs. The different colors indicate the ability for one party to publish a transaction and spend a output; Alice can broadcast the purple transactions and Bob the blue ones. The timelock is enforced by the number confirmations on the commitment transaction. A transaction is confirmed when included in a block. When more blocks get added on top in the chain the transactions have more confirmations~\cite{antonopoulos2017mastering}. For the timelock/RSMC case, it will make the party which publishes the commitment transaction unable to spend their output of that transaction until it has a set number of confirmations. In the Lightning Network paper~\cite{poon2015bitcoin} they uses 1000 confirmations, which will take a while when considering a 10 minute block interval.
\\

\begin{figure}[ht]
    \centering
    \includegraphics[width=12cm]{figures/ln_timeout.png}
    \caption{Different commitment pairs. Source:~\cite{poon2015bitcoin}}
    \label{fig:ln_timeout}
\end{figure}

The need to wait for confirmations to spend the output is enforced on every set of created commitment transactions. It enables the punishment as it allows to other party to spend the output before the timelock expires. However, the punishment only applies to old commitment transactions, and so the punishment is only made possible when a commitment transaction pair is invalidated by creating a new one. The invalidation or revocation of old commitment transactions is done by creating a Breach Remedy transaction which spends the same output as the timelocked/RSMC output. Each of the parties signs this transaction spending the timelocked/RSMC output of their own commitment transaction, and then gives it to the other party to revoke it. This enables both of them to spend the timelocked output belonging to the other party if they should publish a revoked commitment transaction-e.g., Alice creates a breach remedy transaction spending her output in the old commitment transaction and sends it to Bob, and he does the same; if either of the two parties now publishes a old commitment transaction, they cannot spend their output at once because of the RSMC/timelock, but the other party can publish the breach remedy transaction, and also spend their own output and thus get all founds in the channel. However, spending the timelocked output should to be done before the timelock expires as the party which published the old commitment can now also spend that output. Both parties should therefore observe the blockchain so they can see if an old commitment transaction is published, allowing them to use the breach remedy transaction before the timelock expires.
\\

Here we will present an example outlining the event occurring if a old commitment transaction is published. Alice and Bob has a channel with the value of 1 coin, to which they each contributed 0.5 coins. They create a funding transaction, a refund transaction which will be the first commitment transaction, paying back 0.5 coins to each, they sign it, and then sign the founding transaction. After the funding transaction is published to the blockchain the channel is ready as can be seen in cref{fig:ln_breach}. We can also see in the Figure, that the current commitment transaction pair (C1a for Alice and C1b for Bob) has two outputs giving each 0.5 coins, one normal (D1b and D1b) and one timelocked Revocable delivery (RD1a and RD1b). Then Alice wants to send Bob 0.1 coins. To revoke the current commitment pair Bob creates his breach remedy (BR1b) which spends his 0.5 of the commitment transaction (C1b); this is the same 0.5 output that used in the Revocable delivery (RD1b). Bobs 0.5 output from his commitment transaction (C1b) can now be spent either by waiting for the timelock (RD1b) or Alice can spend it using the breach remedy (BR1b) she received from Bob.
Alice does the same thing and sends it to Bob. Now that the old commitment transactions (C1a and C1b) are revoked, they can create the updated pair (C2a and C2b) witch the new balance which outputs 0.4 to Alice and 0.6 to Bob. Now Bob decides to broadcast the old commitment transaction (C1b) to the blockchain. A strange decision since in the old balance he has 0.1 coins less, but it is still a violation of the agreement in the channel of not broadcasting old commitments. 
He cannot claim his Output1 with 0.5 coins from the published commitment (C1b) immediately, as he must wait for 1000 confirmations to do so because of the Revocable delivery (RD1b).
Alice sees on the blockchain that an old commitment transaction has been published. She has access to her output0 with  0.5 coins from the published commitment (C1b) at once, as it was Bob who published the commitment. She also publishes the Breach remedy transaction (BR1b) she received from Bob when they revoked the commitment transaction. This spends Bobs output and she will therefore get the all the value in the channel. The fig.\ref{fig:ln_breach} shows this process with green indicating that a transaction is published to the blockchain and therefore invalidating the other transactions. We can also see how the breach remedy transactions (BR1a and BR1b) are able to spend the same outputs as the the timelocked (RD1a and RD1b).


\begin{figure}[ht]
    \centering
    \includegraphics[width=14cm]{figures/ln_breach.png}
    \caption{Publishing old commitment transactions. Source:~\cite{poon2015bitcoin}}
    \label{fig:ln_breach}
\end{figure}

Publishing a old commitment transaction as described above will spend the founding transaction and close the channel in addition to the other implications already described. If the most recent commitment is published it will also close the channel and place a timelock on the output to the party who published it, but there will has been no Breach Remedy transaction exchanged for that commitment pair, since it has not been revoked-i.e., each party will only be able to spend their output since no channel agreement has been breached.
The channel can also be cooperatively closed if both parties agrees to do so. They simply create a new transaction spending the founding transaction with the outputs reflecting the balance in the latest commitment. They exchange signatures and it can be published on the blockchain. The outputs of this transactions will not have any timelocks, so each party will be able to claim their founds when they wish.
This is because they both have to agree to close a channel this way, if they cannot agree one party can simply publish their newest commitment transaction and close the channel that way, but they will need to wait for the timelock.
Closing a channel co-imperatively means that the total number of transactions published to the blockchain will be less, one founding and one closing, instead of the extra timelocked (or potential breach remedy) transactions.

\subsection{Networked Payment Channels}
\label{subsec:networkpcln}

The payment channels is used by two entities to exchange founds with each other. The LN is formed by having many such interconnected channels, forming a network. This means that a user has the ability to send founds to others across other users payment channels. If everyone needed to create a payment channel with everyone else it would not be very useful or effective, so there are additional mechanisms that allows for payments to be routed across other users payment channels.
As explained in the previous section, the payment channels used in the LN does not require trust between the two parties in the channel. There is also mechanisms that makes sending  payments across channels not requiring the sender to trust the intermediary nodes along the path. The construction that enables this is called Hashed Timelock Contracts (HTLC).
It creates contracts where intermediary nodes have a guarantee that they can get their money from the sender, if they first transfer to the receiver. By having the intermediary nodes first pay the receiver and then get money from the sender, one stops the intermediary nodes from not passing the founds along to the receiver. If the intermediary was sent the founds first, they could simply not pay the receiver and keep the founds. But for the intermediary nodes to accept this, they need to be sure that the sender will pay them what they have already given the receiver. This is the guarantee provided by the HTLC construction.
It uses a hash function with an input or preimage {\tt R}; the receiver inputs {\tt R} into the function and gets a hash {\tt H} which is given to the sender. The sender then promises to pay the intermediary if they can provide {\tt R} that generates {\tt H}. The intermediary then makes the same promise to pay the receiver if they can provide a {\tt R} that generates {\tt H}. Now a chain of promises has been created, each promise being to pay a amount with condition of providing the input {\tt R} which generates {\tt H}. Because it was the receiver who created {\tt H} using {\tt R}, and therefore has access to {\tt R} they can give it to the intermediary and get the founds from them. {\tt R} has now been disclosed to the intermediary, which in turn can use it to get the founds from the sender as previously promised. This can easily be extended to include more intermediaries.
\\

The promise to pay someone in exchange for disclosing {\tt R} generating {\tt H} is not simply a promise. It is a part of a transactions which needs {\tt R} to be valid. When the sender promises to pay the intermediary, the sender is no longer in control of the founds because a transaction containing this clause has been created and given to the intermediary. So the founds are in a way transferred in a manner and direction one would expect (from sender to intermediary, then intermediary to receiver), but having the clause of providing {\tt R} generating {\tt H} to be claimed. A timelock is used to ensure that if no R is provided, the founds can be returned back to the creator of the transaction-i.e., the one who made the promise to pay if provided the right {\tt R}. This ensures that the founds will either be delivered or returned by setting a deadline for providing {\tt R}. If no such thing existed the series of transfer needed could be delayed or stopped completely by nodes not providing {\tt R}.
Using an example, and both \cref{fig:htlc_promise} and \cref{fig:htlc_settle} we can see how this works in detail.
Alice wishes to send founds to Dave, but to do so she must first send them through Bob and Carol. Dave the reciver creates the hash {\tt H} using the preimage {\tt R} and sends {\tt H} to Alice. She sees that there are tree hops for the founds to reach Dave, so she creates the first HTLC with a three day timelock, and sends it to Bob shown as step 1 in \cref{fig:htlc_promise}. To re-iterate: the HTLC is part of a transaction where the preimage {\tt R} has to be given for the founds to be claimed, if {\tt R} is not given within the timelock timeframe (three days in this case) the founds can be reclaimed by the creator of the HTLC. Bob creates a new HTLC for Carol with the same condition except that the timelock is two days shown as step 2 in \cref{fig:htlc_promise}. In step 3 Carol creates a HTLC for Dave with the timelock set to one day. At this point the founds have been sent but no one has claimed the founds from the HTLC's, so the payment is not complete. If Dave does not disclose R and claim the founds from the HTLC he received it will time out, and so will eventually the other HTLC's, meaning all founds will be returned.
\\

\begin{figure}[ht]
    \centering
    \includegraphics[width=11cm]{figures/htlc_promise.png}
    \caption{Series of HTLC's between nodes. Source:~\cite{poon2015bitcoin}}
    \label{fig:htlc_promise}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=11cm]{figures/htlc_settle.png}
    \caption{HTLC founds claimed. Source:~\cite{poon2015bitcoin}}
    \label{fig:htlc_settle}
\end{figure}

In \cref{fig:htlc_settle} we see how the payment is completed with steps 4, 5 and 6. As it is Dave who knows {\tt R} he must start the process. In step 4 he reveals {\tt R} to Carol to claim the founds in their HTLC. Carol can then do the same with Bob in step 5, and finally step 6 where Bob can claim his founds from Alice.
Now the founds have been fully transferred from Alice to Dave.
The reason that the timelock are shorter the closer we get to the final destination of the payment, is that it ensures that each person has time to claim the founds from the preceding one. Lets say that step 3 in \cref{fig:htlc_promise} had a timelock of 5 days, and Dave waited 4 days to disclose {\tt R} to Carol and get founds from her. The HTLC from Bob to Carol would have expired by then and Bob would have reclaimed his founds, meaning Carol has lost her founds to Dave without any way of getting them back.



\subsection{HTLC inside the payment channel}
\label{subsec:htlcln}

The previous section explained the high level functioning of HTLC's and how they are used to transfer founds across different payment channels.
Here we will explain how the HTLC construct interact with the already established dynamic within a payment channel.
A HTLC inside a payment channel will be a output of commitment transactions. The outputs of commitments reflects the balance between the parties inside the channel as previously mentioned, so by having another output we can also reflect HTLC founds in transit. The HTLC output is a special type of output; it is a output script which has two different paths to redeeming the output: one is by providing the preimage R, and the other is by waiting for the timelock to expire. 
As an output of commitment transaction the HTLC will use some of the founds available in the channel determined from the founding transaction. E.g., the value of a channel is 10 coins with a 5 to each balance, a HTLC for 1 coin will be reflected in the commitment transaction as the sender of the HTLC having only 4 coins and the reciver havning 5, but the total value of the channel will still be 10 (4 sender, 1 HTLC, and 5 receiver). If they both agree on who can spend the HTLC output, with either the receiver knowing the preimage R which means the receiver can spend it, or the timelock has expired enabling the sender to spend it, then they can cancel the HTLC by creating a new commitment transaction reflecting the new balance. 
This new balance is either the receiver getting the value of the HTLC, or the sender getting it back. This is how HTLC's are resolved off-chain when the parties agree on either parties ability to spend the HTLC output, and they therefore create new commitments to reflect this. If they cannot resolve the HTLC in this manner they can do so on-chain, similarly as they could with commitment transaction by broadcasting them if they could not close the channel cooperatively. 
The two ways spend a HTLC output on-chain is either by waiting for timelock to expire, or provide the preimage R, both creating a transaction spending the output. As these transactions spend a output from a commitment transaction, the commitment transaction itself would also need to be broadcast on the blockchain, so one be able to spend its outputs. As explained earlier both parties have the opportunity to broadcast their commitment transaction, but restrictions will apply for the publisher. The timelock, and revocation of old commitments with breach remedies, enforces the agreement in the channels.
The same mechanism is used for the HTLC output in the commitment transactions. Using the example of Alice and Bob having a 1 coin channel with a 0.5 to each balance we can see how this works. Alice sends Bob 0.1 coins using a HTLC and they create a new pair of commitment transactions (C2a, C2b) as shown in \cref{fig:htlc_commit}, where Alice has the ability broadcast the purple squares ones and Bob the blue.
\\


\begin{figure}[ht]
    \centering
    \includegraphics[width=14cm]{figures/ln_htlc.png}
    \caption{HTLC outputs in commitment transactions.  Source:~\cite{poon2015bitcoin}}
    \label{fig:htlc_commit}
\end{figure}


If the sender, in this case Alice, is the one who broadcasts the commitment transaction (C2a), she will have the restrictions discussed previously placed on her.
As Alice published the commitment, the left side of \cref{fig:htlc_commit} will be used, as Bob's commitment (C2b) wil be invalid. The commitment transaction (C2a) published has three outputs: output0 is 0.4 to Alice herself (RD2a), but since it is her commitment transaction it will be timelocked; output 1 is 0.5 for Bob, which he can spend immediately (D2a); output 2 is the HTLC which has two different output paths, Bob can spend it at once by creating a transaction containing the preimage {\tt R} (HED1a), or Alice can spend it (HT1a) when the 3 day timelock expires. But because Alice was the one publishing the commitment, her transaction spending the HTLC output will also be timelocked. The timelock of the HTLC output was to ensure that HTLC's are either delivered or refunded. This timelock being placed on the transaction spending the HTLC is to enable the same punishing mechanism as discussed earlier. When old commitment transactions are revoked, so should the HTLC's. This means the parties exchange keys for the transactions spending the HTLC output. 
So if an old commitment transaction is broadcast, the party who broadcast it will also loose the HTLC output in addition to the normal output, since the other party will be able to spend it and broadcast to the blockchain before the timelock expires. Similar as the commitment transactions, each party will have their own version timelocking their outputs as can be seen in \cref{fig:htlc_commit}. As the HTLC transferred value from Alice to Bob, he can spend by providing {\tt R}, but if this is not done, and a newer commitment is created removing the HTLC giving the value back to Alice, Bob can publish the now revoked commitment containing the HTLC, and spend the output using {\tt R}. This is why the the timelock is enabled on the transactions spending the HTLC output (HTRD1a and HERD1b). 
\\ 

Similarl to channel operation without HTLC's, it is desirable to avoid publishing to the blockchain unless it is necessary. The parties can cooperate and agree on new commitment transactions with or without HTLC outputs. To resolve a HTLC one of the parties must simply prove to the other that they are capable of spending the HTLC output, and can do so on the blockchain if they wish. If Bob is the receiver he can publish the commitment transaction, and if he has the preimage {\tt R} he can also create a transaction spending the HTLC output. As he is the broadcaster he must wait for confirmations on both, but will eventually receive his founds. If Bob does not have the preimage {\tt R} and the timelock has expired Alice can now spend the HTLC output. Since they can prove to the other party that they have this possibility, they can instead create a new commitment transaction pair with the HTLC value either transferred to Bob or returned to Alice, thereby keeping  commitment transactions off-chain and have the channel remain open. When doing this they need to invalidate their old commitment transactions and also the HTLC output of these by exchanging keys allowing the other to spend their transaction spending the HTLC output. This allows the parties to transfer founds with a HTLC inside a channel in a trustless manner, which again enables transfers across multiple channels.
No transactions need to be broadcast to the blockchain unless one party is unresponsive or unwilling to cooperate. But with the addion of HTLC's inside a channel, the total transactions published on-chain will be higher, if they cannot be resolved off-chain.
When using the HTLC construct to send founds across multiple channels as shown in \cref{fig:htlc_settle}, broadcasting to the blockchain as discussed in this section will ensure the transfer will finish, in the event of a node not co-operating as illustrated in \cref{fig:htlc_bc}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=10cm]{figures/htlc_bc.png}
    \caption{Settlement of HTLC using the blockchain in the event of a unresponsive node. Source:~\cite{poon2015bitcoin}}
    \label{fig:htlc_bc}
\end{figure}

%RELATED WORK

\section{Related Work}
\label{sec:related}

Most of the work already done in regards to blockchain analysis does not consider the LN, as the work proceeds the inception of the LN. But their approach and methods can nevertheless be relevant for this project.
The fact that the blockchain is a public distributed data-structure containing all transactions done by every Bitcoin user, it is, by its nature something that limits privacy. Analyzing the blockchain can theoretically give us all records of all transactions related to a single individual; this will include the amount sent and received, the time and date this was done, and which addresses these transactions was going to or coming from. As discussed in \cref{subsec:scripts} the addresses are encoded public key hashes, and keys can be generated at will, so users are free to use new addresses whenever they want. It is therefore considered best practice to generate a new address for each transaction, because doing so results in transactions between different addresses each time. For the rest of this paper we will use use the term keys as addresses is just hashed and encoded public keys. 
The practice of not reusing keys means there is no longer a 1-to-1 mapping between users and addresses.
This use of new keys for each transaction gives the users Pseudonymity, which is defined by by Pfitzmann and Khntop~\cite{pfitzmann2001anonymity} as: "Pseudonymity is the use of pseudonyms as IDs.". They also define pseudonymity in relation to linkability, which depending on the context has different levels of anonymity. One of these which is very relevant for our scenario is the transaction pseudonym. For this context they explain that for each transaction a different pseudonym is used, like a random number. This makes different transactions pseudonyms hard to link by themselves, which will give it strong anonymity. The transaction pseudonyms is exactly how the Bitcoin system enables some degree of privacy for its users. Having a new pseudonym for each transaction makes it difficult for observers to link the activity of users. This relates to the privacy notion of unlinkability which is also discussed by Pfitzmann and Khntop; it refers to the inability to find a relation between two items in a system. 
In regards to key reuse, a key is obviously related to itself, but they will also be the relation between the transactions the keys are used in, allowing us to also link the transactions.
According to Pfitzmann and Khntop unlinkability is one of three main concepts of anonymity and privacy. The other is anonymity, which is defined as such: "Anonymity is the state of being not identifiable within a set of subjects, the anonymity set."~\cite{pfitzmann2001anonymity}, and unobservability which means that no message is any different from random noise-i.e. encryption. The latter is not applicable to the Bitcoin system as it is a open system with a public record of messages (transactions) which is observable to the same degree by every participant. The system is also not anonymous as the subjects is distinguished by their keys.
\\

Pseudonymity and unlinkability are the two privacy concepts used to avoid full transparency of activity within the system. A paper by Androulaki ~\cite{androulaki2013evaluating} suggests two privacy notions adapted to Bitcoin: activity unlinkability and user profile indistinguishability. The latter refers to the inability of a observer to link keys or transactions belonging to the a single user of their choosing, and therefore revealing all the users activity. This is a more specified unlikability notion describing the lack of relationship between keys and transactions for a single user. User profile indistinguishability on the other hand is privacy for all users in the system. A user profile can consist of keys or transactions which are linked, meaning they are discovered as belonging to the same user. User profile indistinguishability means that a observer should not be able to link keys or transactions to the right user, and thus to construct correct user profiles. The linking of keys allows us to say that a set of keys belong to the same user, while the linking of transactions mean that a user have participated in that set of transactions in some way. As noted by Androulaki et al.~\cite{androulaki2013evaluating} key linking entails transaction linking because keys is contained within transactions; still there is room for transaction linking because other information might make us able to link transactions without being able to link keys. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=14cm]{figures/key_network_related.png}
    \caption{ Transaction network with keys shown.}
    \label{fig:transaction_graph_keys}
\end{figure}

The research already conducted has focused on linking information found in the blockchain to negate the pseudonymous properties of Bitcoin, and thus create user profiles~\cite{meiklejohn2013fistful,androulaki2013evaluating,reid2013analysis,ron2013quantitative}. To create profiles we need to link information that is related; this means linking transactions to transactions, and keys to keys. A simple way of linking transactions is using the fact that they are naturally related trough the output - input structure, creating a DAG as shown in \cref{fig:transaction_graph} and in the background of \cref{fig:transaction_graph_keys}. This graph will show us the relation between the transactions (nodes) connected with output - input (directed edges). However, this network will only show us how transactions are related and not much about the users, because the pseudonymous properties of the keys. This problem is illustrated in \cref{fig:transaction_graph_keys} where we have overlaid the keys and the flow between them. We have seven total keys in this transaction sub graph, and with one key being used twice, the unique number of keys is six. Without linking keys the number of possible users will be the same as uniqe keys, as we can not easily determine if two keys is a uniqe user or the same user with  new key. Linking keys will create a set of keys controlled by the same user or entity, which means we have reduced the set of possible participants in the transaction graph. If we could link all keys related to a user, we would be able to find all activity that user participated in on the blockchain. Using the set of keys related to each user, we can create a user network similar to the transaction network, but where the nodes is users in addition to transactions, and the edges is the output-input pair from the transactions-i.e., showing the flow of Bitcoin from one user to another as illustrated by~\cref{fig:user_graph}. 
This user network shown in~\cref{fig:user_graph} allows us to discover how founds is moving between users instead of just keys as was illustrated in ~\cref{fig:transaction_graph_keys}. Reid and Harrigan~\cite{reid2013analysis} created such networks in their paper analyzing Bitcoin privacy. In a paper reviewing Bitcoin privacy papers, Herrera-Joancomarti~\cite{herrera2015research} states that this user network allowed Reid and Harrigan do user centered analysis, giving context to the data in the blockchain. Reid and Harrigan also created a ancillary network when linking keys (nodes being a uniqe key and edges being a relation between two keys); This network would contain the key sets found for each user, each set represented by a maximally connected component in the network. A different type user network was created by Meiklejohn et al.~\cite{meiklejohn2013fistful}: not structured as the transaction graph as the one in \cref{fig:user_graph}, but instead only showing users outside the context of the transaction graph. Each node is a user (linked key set) and the edges was any transaction between the two, showing us if a pair of users done any transactions at any point in time. These network illustrates the main goal of linking information: user profiles. A set of linked keys representing a user will allow us to see the activity of that user and so we have a profile of that user.\\
 
\begin{figure}[ht]
    \centering
    \includegraphics[width=14cm]{figures/usernetwork_related.png}
    \caption{ User network after linking addresses}
    \label{fig:user_graph}
\end{figure}

The research done in this field has used two heuristics for linking keys. The first one has been used by several projects~\cite{reid2013analysis,meiklejohn2013fistful,androulaki2013evaluating,ron2013quantitative} and was also pointed out by Satoshi Nakamoto in the Bitcoin whitepaper~\cite{nakamoto2008bitcoin}. Keys used in transactions with multiple inputs can be said to belong to the same entity. As we explained in subsection \cref{subsec:scripts}: spending outputs requires signatures in the input, from the private key paired with the public key used to lock the output. A transaction with multiple inputs means that the all keys must have been available to sign the inputs, and so it is very likely that the creator of the transaction controls all keys used. If we consider \cref{fig:transaction_graph_keys} we have two transactions with multiple inputs, and we can therefore link keys 1 \& 2, and keys 2 \& 4. As noted by Meiklejohn et al.~\cite{meiklejohn2013fistful} this effect is transitive, which means that by linking the keys from \cref{fig:transaction_graph_keys} as done above, we can also link key 1 and 4, because both are related to key 2 which reused in the two transactions, so they must also be related to each other. By doing this we have a set of three unique keys controlled by one user; we can now use this set to define a user (user 2) in the user network as shown in \cref{fig:user_graph}. The second heuristic utilizes "shadow addressees" first explored in~\cite{androulaki2013evaluating} and then later refined in~\cite{meiklejohn2013fistful}. Because a output has to be spent in its entirety, a user wishing to transfer a value less than the value of available outputs must send the remainder back to themselves. A real world example of this is receiving change when paying with a cash bill having higher value than the price of the item bought. Most Bitcoin software implementations known as wallets allowing users to do transactions, create outputs to transfer change back to sender automatically with a new key each time. Transactions doing this have multiple outputs: normal ones sending value to another entity, and a output giving back the change to the sender. The creation of this shadow address (key) and the locking of the output to this key is handled internally by the software, and users would not necessarily know the address, which makes it unlikely it is given to others for receiving transactions. This heuristic relies on the fact that these keys will only be used to receive the change in one transaction, and not in any other transactions. It also relies on people not using a single transaction to send value to multiple people, as the linking consists of finding multiple output transactions and assuming the shadow address is a key not used before in the transaction graph. Meiklejohn et al.~\cite{meiklejohn2013fistful} also notes that this relies on the implementation of wallet software, and is not a inherent property of the Bitcoin system itself. 
Applying this heuristic to the transaction graph with keys overlaid in fig.\ref{fig:transaction_graph_keys} we will find one multi-output transaction with founds going from key 0 to key 2 and 3; key 3 has not been used before or after in the transaction graph while key 2 has, so it is very likely that the output to key 3 is change returned to the same user controlling key 0. \cref{fig:user_graph} shows the final result of the user graph, where we now have reduced the set of possible users from six to three by applying the two heuristics for linking keys.
\\

The two heuristics discussed above for linking keys, uses information or characteristics from the Bitcoin system itself. However one can also link keys by using off-network information-i.e., sources outside the Bitcoin system.
Reid and Herrigan~\cite{reid2013analysis} also used this approach and provides this example: exchanges allowing users to sell, buy, withdraw, and deposit Bitcoin will have access to the keys users utilize for depositing and withdrawing; which allows them to link those keys based on the user profile. However, this information is not publicly available but the method can be used for other types of services or data sources. People publicly disclosing multiple keys so they can receive Bitcoin is one such way. Reid and Herrigan~\cite{reid2013analysis} provides another example that is publicly available. A Bitcoin faucet is a webpage where people can donate Bitcoin which other users can receive a small amount of. The log of the redistribution containing ip-address of receivers is published to prevent abuse. This means that a reoccurring ip addresses can be used to link keys, similarly as an user profile. The information used for linking outlined above exists publicly on the internet, but one can also link keys by actively gathering this data. This was done in the study by Meiklejohn et al.~\cite{meiklejohn2013fistful}, were they participated in mining pools, withdrew and deposited founds on exchanges or wallet services, used bitcoin gambling sites, and purchased goods from vendors. By doing this they were able to collect keys related to the different services and entities they did transactions with. 
This shows that engaging with other entities or users multiple time will allow us and them to link keys used in those transactions.
A important remark about this, done both by Meiklejohn et al.~\cite{meiklejohn2013fistful}, and Reid and Herrigan~\cite{reid2013analysis}, is that a big entity in the network which does transactions with a large number of other separable users will have greater opportunity to identify or track users, because they are able to use their central position to link keys. Such a entity could be a big exchange where people trade other currencies for Bitcoin, where by using the identifying information separating their users, and also the two heuristics discussed in the previous paragraph, they could link keys, create user profiles and thus track activity of many Bitcoin users.
\\

Herrera-Joancomarti et al.~discusses in their paper~\cite{herrera2016privacy} privacy in relation to Bitcoin scaling solutions, and points to several problems with blockhain analysis. One central issue is the increasing size of the blockchain as it constantly grows. Herrera-Joancomart et al. states that at the time of writing that paper the blockchain was 72 GB. The papers discussed earlier in this section, performed their analysis in 2013 when the blockchain was around 8 GB. At the time of writing this thesis, May 2018, the size of the blockchain is over 165 GB~\cite{blockchain_size}.
Herrera-Joancomarti et al.~also points out that the linking heuristics used in previous studies are no longer applicable for off-chain transactions facilitated by networks like the LN. This is simply because the transactions will not be recorded on the blockchain. Herrera-Joancomart et al.~suggests that using payment channel networks will increase the privacy of users with regards to blockchain analysis, but that the existing methods may be adapted to analyze the payment channels in a network such as the LN. 
It has been suggested that identifying founding transactions on the blockchain can imply the network topology~\cite{rusty_routing1} of the LN. This is because all channels in the LN must be anchored in the blockchain with a founding transaction signed by both parties in the channel. If one where able to identify founding transactions on the blockchain, and also had some way of linking channels (represented on the blockchain as founding transactions) to each other, it wold reveal how the LN is structured as the linked channels would form the same network as the LN. This possibility is also mentioned in the LN paper itself~\cite{poon2015bitcoin} were they state that by monitoring the blockchain for founding transactions, a routing map of the LN can be theoretically built.
Similarly, by linking the founding transaction and closing transaction of a channel, we get closed channels, so linking it with other channels would give us the structure of the LN in a previous state. 

% ---------how anoyimity is handled within the LN, if included must also be discussed later.

%There has been identified several factors in the LN that will impact anonymity. Herrera-Joancomart et al. \cite{herrera2016privacy} suggest that the typology of the LN will greatly affect privacy. They propose that a possible typology for the LN is one were there are some highly connected core nodes that have big capacity channels with each other, while the end users connect to one of these each when they want to do transactions. In contrast to the Bitcoin network which is a decentralized p2p network, the LN with this topology will be a more centralized one. The number of core nodes and how many connections they have will of course play a big role in the degree of centralization. But any degree of centralization with some nodes being more connected than others will likely have a effect on anonymity. These nodes may be in a position to know both source and destination of payment done in the network. Which violates the privacy notion of relationship anonymity for payment channel networks suggested by Malavolta et al. \cite{malavolta2017concurrency} discussed in section 2.1. However, onion routing \cite{LN_onion_implementation} has been implemented for the LN which provides relationship anonymity. In the payment path a node will only know where it received the payment from and where to forward it to. It cannot know if where it received it from was the sender or just another node in the path, or if the next node is the final receiver or just another forwarder. 

%The mechanism used to transfer the payments over multiple channels in the LN is called Hashed Timelock Contract (HTLC). This contract states that the receiver must supply a preimage (input used in a hash function) to claim the founds from the contract; if this is not done within some time frame the sender will get their founds back. Each node in the path, from the sender to receiver promises to pay the next node by using the HTLC. So, a HTLC between two nodes is created for each hop in the path. The final receiver then discloses the preimage to the node before it in the path, which in turn can now get the founds from the node before it because it now knows the preimage.  This happens until the founds are pulled from the original sender. The term contract is used because if one of the nodes breaches the terms, the contract can still be enforced by using the blockchain to broadcast transaction data and close out the channel to claim the founds. In this manner two parties can transfer founds in a payment path containing untrusted intermediaries. Malavolta et al. \cite{malavolta2017concurrency} points out that this preimage is the same for each HTLC in the path for a payment, it can therefore be used as an identifier among many payments done by the nodes in the network. This means that two nodes can determine that they both where in the path of of the same payment by comparing preimage value. They also suggest that if a node in the path is uncooperative and the HTLC is enforced on the blockchain, the data broadcast there containing the preimage can be used to find the path used for the payment, even without being part of the payment path.



%The recent paper by Malavolta et al. identifies some privacy notions specifically for payment channel networks \cite{malavolta2017concurrency}. The two notions are value privacy and relationship anonymity. Value privacy is that users outside the payment path cannot learn the value of the payment. A payment path is the route the payment travels inside the network. The notion is specified to only be off-path meaning it only considers nodes that are outside the path, so the nodes in the path will learn the value. Relationship anonymity is a more general anonymity concept which relates to likability. Pfitzmann and Khntop \cite{pfitzmann2001anonymity} also defines this concept and explain that it relates so sender and recipient anonymity but is a weaker anonymity concept. Relationship anonymity means that the relationship between sender and receiver is unlinkable; who sends a message can be discovered and similarly who receives a message, but their relationship can not. Malavolta et al. \cite{malavolta2017concurrency} suggests that this concept is a relevant property for on-path payments in payment channel networks. This means that the nodes that are in the payment path in the network will not be able to link the sender and receiver of a payment