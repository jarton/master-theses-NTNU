\chapter{Methodology and Implementation}
\label{chap:metodology}

%goal 
To meet our goal for this project as outlined in \cref{chap:introduction} we must create a method for identifying LN relevant transactions on the blockchain, so we can discover what information is available in those transactions. In \cref{sec:background} we covered how the LN uses the blockchain to operate with certain on-chain transactions. This means the relevant on-chain LN transactions we are interested in is the ones used to open, close, or claim founds related to a channel. Because we are interested in what we can learn about the LN and its users from analyzing the blockchain, we will not utilize the information in non LN relevant transactions in this project. Reason behind this is the size of the blockchain as discussed in \cref{sec:related}, which means the requirements for both software and hardware will be high if all information in the blockchian should be kept track for parsing. The benefits of taking all information into consideration for a similar type of project is discussed in \cref{sec:future} on future work. 
\\

%blockchain vs ln
With the LN being layered on top of Bitcoin, it requires the Bitcoin system to work while the opposite is not the case. The LN will also be aware of the state of the Bitcoin system, as it uses the Blockchian to operate the channels. The Bitcoin system on the other hand is unaware of the LN and does not distinguish between on-chain LN transaction and other transactions. This means that when we use the Blockchian in the Bitcoin system as the source of data, it will contain little information about the LN and without context, compared to using the LN and view the system from there. However, the LN is a dynamic changing network of nodes, channels, and payments; which is not stored in any public ledger like the blockchain. The information found in the LN can be recorded and stored by participants but the system itself does not keep such a record. The data in the blockchain can be verified by any user as explained in \cref{subsec:blockchain} while data recorded from the LN could not be verified in the same manner on its own.
This means that if we want verifiable historical data about the LN we should look in the blockchain. It will have limited and less information than what can be found in the LN, but will have the properties of being verified and automatically recorded by the system.
While our approach is the blockchain we can also use the fact that there is more information available by connecting to the LN and record data. Collecting data from the LN will allow us compare it with what we find on the blockchain. Doing this comparison we can verify our method for identifying LN relevant transactions on the blockchain, and indicate how much of the total information is available on the Blockchain.
\\

\section{Blockchain analysis}
\label{sec:bc_analysis}

\subsection{Main identification method using timelocked outputs}
\label{timelocked_identification}
%subgraphs representing channels
The transactions in the blockchain is linked with outputs - inputs forming a DAG as we explained in \cref{subsec:transactions}. Parsing the blockchain involves linking these transactions to form this transaction graph, allowing each transaction can be seen in context with every other. When applying the heuristics used by previous works discussed in \cref{sec:background}, one can use the results of this to provide additional context to the graph-i.e., when users are defined by key sets, it will remove the pseudonymous properties of using new keys for each transaction, and thus reveal user activity. Because we are interested in transactions related to the LN, we do not create a complete transaction graph containing all transactions on the blockchian; instead we only link transactions related to a single LN channel, which creates many small transactions graphs, each representing LN a channel, and each a subgraph of the complete transaction graph. 
We will refer to these graphs as channel graphs because they contain all on-chain transactions related to a LN channel.
By only creating the channel graphs and not a complete transaction graph, we do not need keep track as much data during parsing of the blockchain. 
In \cref{fig:ln_tx_graph} we can see the types of transactions found within a channel graph for a unilaterally closed channel. 
We have the two main transactions present in all types of channel graphs, which is the founding and closing transaction, but we also have what we call the timelocked transaction, which spends the timelocked output in the case of a channel being unilatirally closed.
This occurs when one party publishes a commitment transaction, which spends the channels founding output and thus closes the channel, meaning the commitment transaction also becomes the closing transaction. As explained in section \cref{subsec:pcln} the one who publishes a commitment transaction will have a timelock on their output from the commitment transaction. This is to enable punishment for the publisher in the case of the commitment in question was a revoked one, containing outdated balance favoring the publisher more than the most recent commitment. 
The timelocked transactioin shown in \cref{fig:ln_tx_graph} is the transaction spending this timelocked output, so it will not be present if there is no timelocked output, which is the case for cooperatively closed channels.
\\

%identifying, craeting subgraphs
To create the channel graphs we must differentiate between on-chain LN transactions and other Bitcoin transactions,
so for locating LN relevant transaction on the blockchain, we identified several attributes required in the transactions shown in \cref{fig:ln_tx_graph}. 
In the two main transactions which is the founding/opening and closing transaction we find the output - input pair which facilities the channel. The founding transaction contains the output creating the channel, and the closing transaction will have the input closing the channel. This output - input pair will be of the type P2WSH 2of2 multisig as we explained in \cref{subsec:pcln}. 
While this will be the case for all output - input pairs used for channel opening and closing, it will not be sufficient to determine with certainty if a transaction is related to the LN or not, because P2WSH 2of2 multisig transactions can be used for other purposes. As we explained in \cref{subsec:scripts} the P2SH (non segwit version of P2WSH) type will only have the hash of the script in the output, while the redeem script itself is included in the input of the transaction spending that output. This means that if we only consider a founding transaction output, we will only be able to tell that the output is a P2WSH type. If we on the other hand only consider the closing transaction, the input will be able to tell us that the output was a P2WSH type and that the redeem script is a 2of2 multsiig script.
Because both of these properties must be present in a LN channel output - input pair, a closing transaction is will enable us to check if the input - output has both of these. Again, these two properties does not guarantee that the input - output is a LN channel, but we can differentiate between possible candidates and transactions that is guaranteed to be unrelated. These candidates can also have different degrees of certainty to be LN related, based on the number of properties we can determine. In practice this means that we will have better success if we try to identify channels by locating potential closing transactions instead of founding transactions, as more distinct properties can be found in the former-i.e., both 2of2 mutlisig and P2WSH, instead of just P2WSH. In this project we have investigated the effectiveness of using the different types of properties, which will be discussed later.
\\

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{figures/chan_graph.png}
    \caption{Channel graph of unilaterally closed channel}
    \label{fig:ln_tx_graph}
\end{figure}

%timelocked tx
In addition to the 2of2 multisig redeem scripts there is other script types used in some LN on-chain transactions. One of these scripts is used when a channel is unilaterally closed. As stated in the LN specification \cite{bolt3} the published commitment transaction has two outputs: one P2WPKH to the party who did not publish, and one P2WSH output for the publisher.
The P2WSH has a redeem script which can be spent in two different ways: by waiting for the timelock specified, it or with a revocation key. This redeem script used in the P2WSH timelocked output is the implementation of revocable deliveries and breach remedies discussed in \cref{subsec:pcln}.
This redeem script has very specific functionality and is therefore fairly unique, and to our knowledge there is no other instances where this type of script is used. However, people are free to create such scripts without it having anything to do with the LN, but the specific use case of such script makes this unlikely. The redeem scripts are located in the transaction spending the P2WSH outputs, so in our case this would be the timelocked transaction spending the timelocked output as shown in \cref{fig:ln_tx_graph}. Using the uniqueness of this redeem script we can identify timelocked transactions by looking for inputs containing these scripts. 
In \cref{subsec:segwit} we explained how each transaction has a id which is a hash of the transaction. This is how the transactions refer to each other; the inputs of transactions contain the transaction hash and output index of the transaction they spend. If we use the redeem script found in timelocked transactions for identifying a LN related transaction, we can get the hash of the commitment/closing transaction because the timelocked transaction uses one of its outputs. The transaction hash allows us to uniquely identify the transaction in the blockchain. Examining the inputs for the commitment/closing transaction we can in turn find the hash of the founding transaction allowing us to locate it. Using the input - output connection between transaction, we can by only identifying the timelocked transaction, get the other transactions in the channel graph. 
\\


%reverse parsing %our software
This method for creating subgraphs with LN related transactions explained above, identifies transactions in the subgraph in reverse order 
compared to their creation order-i.e., we will first find the timelocked transaction, and the founding transaction last. As stated before the tranasctions form a DAG, meaning they will be located chronologically in the blockchain, with newer transaction being found at the tip of the chain. For our channel graphs this means that closing transactions will located before the founding transaction because the closing uses the output of the founding.
Because we identify the transactions in the channel graph in reverse order, we must parse then the blockchain in reverse order starting from the latest block working our way down towards the start, ensuring we encounter the transactions in the correct order. 
We should however note that this method will only identify closed LN channels with the timelocked output spent, as the timelocked transaction is required to locate the channel graph. 
\\

The software we have developed for this project parses the blockchain and identifies relevant transactions, by mainly using the method outlined above.
We use the btcd \cite{btcd_roasbeef} Bitcoin implementation written in Go, for fetching and storing the blockchain data, and we also use its libraries to read the data in our software.
At a high level our software finds the latest block from the blockchain stored on disk and uses it as a starting point;
it then iterates over the transactions in the block, and checks if they are relevant for our project-i.e., is part of a channel graph. If that is the case they are stored for later use. After all transactions in a block is parsed, the hash of the preceding block is used to fetch it from the disk, and the same process is repeated.
The main algorithm used in our software for parsing the blockchain and crating channel graphs is shown in \cref{fig:algo}. It uses the method described above, where timelocked transactions is identified using redeem scripts, and then transaction hashes of inputs was used to find the rest of the graph.
The algorithm checks each transaction if it is a timelocked transaction, if so we store it as the end of a channel graph. In addition we store the hash of the preceding transaction, which would be the closing/commitment transaction. As we parse transactions and identify more timelocked transactions, we are creating a list of hashes known to be closing/commitment transaction. Therefore, for each transaction we check which does turn out not to be a timelocked one, we instead check if its hash matches any in this list-i.e., if it is a closing/commitment transaction. If it matches we store it within its graph, and then get the hash of the preceding transaction, in this case the founding transaction, and store it in a similar list. 
Transactions is checked against this list if a transaction is neither a timelocked or closing/commitment transaction.
If a match is found in this last list a founding transaction is identified and we have a complete channel graph. 
The hash lists used to find all other transactions besides the timelocked, are for each transaction checked in the reverse order, meaning we check the hash list containing closing transactions before we check founding transactions. Even while doing this we had to implement mechanisms for dealing with out of order transactions. As stated before, the inclusion of transactions in blocks naturally orders them, because 
transactions added in new blocks must have inputs from transactions already in the blockchain. However, transactions pairs where one spends another can be confirmed at the same time, meaning they are included in the same block.
This occurs because the creator of the latest transaction spending a unconfirmed transaction-i.e., a transaction that has not yet been accepted as part of the shared transaction history of the network. 
Transactions are not necessarily ordered within blocks, so if two sequential transactions are located in the same block, we might encounter the latter transaction first. This means we might encounter the founding transaction before the closing, but since we have not yet found the closing transaction and thus did not know the hash of the founding we could not yet recognize it. Because if this we had to iterate over the transactions in the block a second time if we found any closing transactions, to make sure we did not miss the founding transaction.
Even with parsing some blocks twice the software parsed blocks fairly quick. The memory requirements where also low as it only had to keep track of the hash lists for transactions we where currently looking for, and the already found transactions stored in their respective channels. 
\todo{add circa time for x amount of transactions}

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{figures/algo_v2.png}
    \caption{Algorithm of parsing and locating relevant LN transactions on the blockchain}
    \label{fig:algo}
\end{figure}


The redeem script sused to identify the timelocked transactions is shown below: \cite{bolt3}
\\

\noindent OP\_IF \\
\indent   # Penalty transaction \\
\indent    <revocationpubkey> \\
OP\_ELSE\\
\indent    `to\_self\_delay`\\
\indent    OP\_CSV\\
\indent    OP\_DROP\\
\indent    <local\_delayedpubkey>\\
OP\_ENDIF\\
OP\_CHECKSIG\\

% timelocked script
The first line is the clause to stop participants from publishing old commitment transactions-i.e., the revocation clause. 
 In  \cref{subsec:pcln} we discussed how the parties will revoke old commitment transactions by exchanging keys, allowing the other party to spend the timelocked output with the key and get all the founds in the channel; this first clause is how this is done in practice.
 A signature to the public key used in this clause, will make script evaluate to true.
 The else clause is the timelocked portion of the script. It will contain the timelock, enforced by the CHECKSEQUENCEVERIFY operation defined in \cite{BIP112}, which will terminate the script if the specified delay has not passed. The delay is then removed from the stack with OP\_DROP such that the signature and public key are the only two items on the stack. Lastly OP\_CHECKSIG is used to verify the signature.
The script will be located as the last item in the witness stack inside a transaction; see \cref{subsec:segwit} where we explained how the witness stack is structured for P2WSH transactions. Below is the raw byte representation of a specific redeem script of the type shown above. It has the same operations and data fields, but has actual values in those fields. We have formatted it in the same manner as the one shown above allowing for easier comparison between the two.
\\

\noindent [99 \\
\indent 33 3 251 83 243 198 231 109 204 252 217 94 44 221 0 255 185 86 106 105 161 141 254 96 
\indent 167 77 48 16 57 146 128 4 80 1 \\
103 \\
\indent 82 \\
\indent 178 \\
\indent 117 \\
\indent 33 2 159 6 236 212 233 63 48 147 59 52 201 11 15 138 165 248 118 100 188 234 227 215 
\indent 108 160 135 22 57 37 117 250 172 130 \\
104 \\
172]
\\

%byte rep of script
As we explained in \cref{subsec:scripts} the operations in Bitcoin scripts is called opcodes, and the Bitcoin wiki contains a list of all of them, and their encodings \cite{bitcoin_wiki_scripts}. The opcodes and their ordering in the script dictates the functionality of the script, so to identify a type of script we should look for scripts having the same format and operations.
The first byte vector seen in the raw script above is 99 which is the opcode for the the OP\_IF operation. The next vector is 33, which indicates how many bytes to push; this is the length of a compressed public key with prefix. Bitcoin uses elliptic curve cryptography, where a public key is two coordinates representing a point on the curve. The prefix for compressed keys can be 02 or 03, which indicates if the y coordinate is even or odd \cite{antonopoulos2017mastering}. So the first byte vector in a compressed public key, and the third byte vector in this type of script will always be 2 or 3, and the 32 next bytes will be the rest of the compressed key <revocationpubkey>. After the public key we will find the OP\_ELSE with the opcode 103, followed by the 82 'to\_self\_delay' which is the delay for the OP\_CHECKSEQUENCEVERIFY (OP\_CSV) operation, being opcode 178. 
Next vector is 117 which is the OP\_DROP operation, and after we find the <local\_delayedpubkey> in the same format as <revocationpubkey>; 33 indicating the number of bytes to push to the stack followed by the prefix and the rest of the key. After that we have 104 which is the opcode for OP\_ENDIF, and 172 for OP\_CHECKSIG.
To identify this type of redeem script in timelocked transactions we check if the opcodes can be found at the expected locations. E.g., index 0 of the script should be 99 for the OP\_IF, 103 for the OP\_ELSE operation should be at index 35, allowing space for a public key between it and the OP\_IF operation. Each opcode contained in these type of scripts is used for recognition, meaning all opcodes covered here must be present in the script for it to be identified as a timelocked redeem script, and they must be found at their expected location relative to the others.
\\


\subsection{Finding channels using P2WSH 2of2 Multisig}

The timelocked redeem scripts used to identify unilaterally closed channels are very unique compared to other scripts commonly used, so when we find such scripts we can safely assume that the transaction is related to the LN. However, as mentioned all channels cooperatively closed will not have a timelocked output and thus no timelocked transaction. Instead they will only have a closing transaction outputting the balance to each party in the channel without any restrictions. With only channel graphs containing founding and closing transactions, we have limited in characteristcs to use for identification. In the \cref{subsec:pcln} and the start of this section we explained how the channel is built on a a P2WSH 2of2 multisig output located in the founding tx, and we also discussed using these properties for identification, and how it allows us to identify potential candidates and can be used to rule out all transactions without these properties.
We have also implemented identification of possible closing transactions by using the P2WSH 2of2 multisig properties; everything except the initial identification being done with 2ofo2 multisig redeem scripts, instead of timelocked redeem script is the same as the general method discussed in \cref{timelocked_identification}.
 When using these properties to attempt to identify channels, we will get a set containing all LN related transction, but it will also have transactions which are unrelated. The effectiveness of this method will be determined on how many of the transactions are related compared to the amount that is not. This again will depend on the current use-cases for 2of2 multisig transactions besides on-chain LN transactions, and how widely these are used. To determine the current effectiveness of this method, we will compare data from the blockchain with data gathered trough the LN, which we will discuss in more detail in \cref{sec:ln_analysis}. 
 The redeem script located in the closing transaction will contain the properties used to identify possible candidates, so again, we will only be able to identify closed channels.
Below is the 2of2 multisig redeem script format, and a example of such a script in bytes:
\\

2 <public key 1> <public key 2> 2 OP\_CHECKMULTISIG
\\

\noindent [82 33 2 211 153 245 240 225 125 95 140 116 20 99 81 38 139 135 136 59 14 125 34 181 148 47 67 16 42 24 147 28 144 61 33 33 2 215 1 70 141 233 112 91 253 252 202 27 73 158 254 234 159 125 98 30 78 159 235 6 46 167 103 105 239 180 125 168 66 82 174]
\\

In \cref{subsec:scripts} we used multisig scripts as an example of redeem scripts used in pay to script hash transactions. They are compared to the redeem scripts used in timelocked transactions quite simple, consisting only of two numbers denoting the required and total number of keys that can be used to sign, the public keys themselves, and the checkmultisig operation. As shown above we start with the required number of keys which must be used for signing, in this case 2, being 82 in the byte version. Then we have the first public key required to spend the output, in the same compressed format as in the timelocked script with a length of 33 bytes, starting with the prefix of either 2 or 3. Then we have the other public key in the same format, followed by the 2 or 82 in byte format telling us the total number of keys which can be used for signing. At the end we have the opcode 174 OP\_CHECKMULTISIG, which checks signatures against the public keys. To identify this type of script we check if the opcodes are present at their expected locations in the script, and the total length of the script. As mentioned channels closed co-operativly will not have the timelocked transaction, so when we use this method to identify possible LN channels on the blockchian, the channel graphs created will be smaller.
\\

\subsection{Non implicit LN intimation on the blockchain}
% how other information gathered. output types so on.

If we can successfully identify channel graphs containing all transactions related to a LN channel, the data in those transactions will allow us to extract some information about the channel. The value of the output - input pair used for the channel, will tell us the total value of the channel. Timestamps is included in blocks when they are created, so by checking the timestamp of the blocks where the founding and closing transactions is located we can see how long the channel was active. The number of inputs in the founding transactions and the number of outputs in the closing is also interesting; a founding transaction with a single input shows that a single user founded the channel; multiple inputs can indicate that both users founded the channel, but there is also a possibility that the channel is still founded by a single user, having multiple smaller outputs to get the desired value of the channel. It is difficult to determine how founds have moved inside the channel based on value of the inputs to the founding transaction, and the value of the outputs from the closing transaction-i.e., it is hard to extract any information about any off-chain transactions by analyzing the outputs and inputs of the on-chain transactions. The reason for this is that normally we can not determine which input/output belong to which user in the channel. We discussed in \cref{subsec:scripts} on how keys are used to lock outputs and signatures using those keys are used in inputs to unlock, so a key pair is normally related to a input-output. In \cref{fig:keys_graphs} we have a founding transaction with two inputs (keys), a mutlsig transaction with two keys, and a closing transaction with two outputs (keys). If we assume each user founded the channel with one input we can determine the initial balance between the parties by checking the value of those inputs. Comparing that balance to the one in the two outputs will tell us how it has shifted from start of the channel to the end, but as discussed in \cref{sec:related} the pseudonymity provided by different key pairs makes us unable to see which of the inputs corresponds to which output. We can also see in \cref{fig:keys_graphs} how the value is initially spread in two outputs then merged in the channel and then spread out again in two outputs, so simply following a specific value will not work. Linking the keys used in these transactions as is done in previous work discussed in \cref{sec:related} will make this possible and is something we will discuss in \cref{sec:linking}. The one thing we can determine by looking at inputs and outputs of a channel, without any key linking, is that a off-chain transaction has taken place in the channel, but this is only the case if there is one input to the funding transaction (single founded) and there is multiple outputs, meaning we know the channel started with with all value belonging to one party and it ends with the parties splitting the value.

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/keys_subgraph.png}
    \caption{Keys in a channel graph}
    \label{fig:keys_graphs}
\end{figure}

We can also get information about the LN by looking at transactions in general and not just channel graphs we have identified.
As we discussed earlier in this section, the on-chain transaction input and output used for the channel itself will be of the P2WSH type. Using this fact we can count the number of unspent P2WSH outputs and thus determine the upper limit of possible open LN channels. 
This can also be done to get the maximum number of LN channels at any historical point of the blockchain; by counting all P2WSH outputs and subtracting the spent ones up to a height on the blockchain will get us the unspent outputs at that point. While this will likely be inaccurate in terms of actual number of channels (size) for the LN, it will give us a concrete upper limit to its size, both current and at any point in the past.


\section{Lightning network analysis}
\label{sec:ln_analysis}

% lnd introduction
This project focuses on exploring the LN and related data trough the blockchain, but we can use other approaches verify and provide context to our methods and information. One such approach is simply to collect data from the LN directly. This data will be more complete than what we can find on the blockchain, so it will provide us with a bigger picture. By comparing blockchain data with data directly from the LN, our methods of locating ln relevant data and their effectiveness can be measured. In \cref{sec:bc_analysis} we discussed using the P2WSH 2of2 multisig transaction output type for detecting on-chain LN transactions, and we explained how we could measure the effectiveness of this method by comparing its results to known information from the LN. The data from the LN can also provide us with the ideal result of linking information from the blockchain. Some relations are explicitly defined in the LN data, but only implicitly on the blockchain, which makes our linking efforts on the blockchain data also measurable.
\\

To collect data from the LN we used the LND implementation \cite{lnd} which follows the BOLT specification \cite{bolt}, and modified it to collect the data we where interested in. The LND software maintains a view of the current lightning network by storing a graph containing active channels and nodes. This is continuously updated as new channels are announced trough the network, and closing transactions is found on new blocks on the blockchain. It requires a Bitcoin instance running to interact with the Bitcoin network, which is used to publish on-chain transactions and monitor the blockchain. New channels are discovered by announcements within the LN while channels closing is found by looking at the blockchain and finding transactions spending the founding transactions of previously active channels. 
Because the software already stores all channels and related data, we only needed to make it keep old data.
To do this we modified the 0.4.1-beta version of LND to create a copy of its database each time a new block notification was received from the Bitcoin software. This was not done immediately but within a minute so the changes from the block could be applied to the graph data. Doing this gave us a set of databases containing the state of the network at each block, essentially a collection of snapshots of the LN.
\\

The snapshots contains the graph describing the state of the lightning network as known to our node at the time of the snapshot, so by comparing the graphs of different snapshots we can see how the network evolves over time. 
Each graph in the snapshots is essentailly a set of channels active at that time. Consider two sets of channels representing the LN at different points in time: \(\kappa\) being the older and \(\tau\) the newer. The channels not present in \(\kappa\) but present in \(\tau\) would be new channels-i.e., the relative compliment of \(\kappa\) in \(\tau\), \( \tau \backslash{}\kappa\). Similarly the channels closed would be the ones present in \(\kappa\) but not in \(\tau\)-i.e., the relative compliemnt of \(\tau\) in \(\kappa\), \(\kappa\backslash{}\tau\). Doing this for each snapshot we can get a set of channels closed and opened during the data collection interval, and because we collect snapshot at each new block, we can easily contextualize the results with different blockheights-e.g., creating a list of closed channels for each block, or number of active channels for each blockheight. This also makes it easy to compare data from the LN to data from the blockchian as we can use the blockheight as a index, ensuring we compare correct data.
Using some libraries from the LND implementation we created software to read and compare the network graphs, and produce outputs with relevant information.
\\

% GRAPH PRUINING


\section{Linking and key reuse}
\label{sec:linking}

% intro clusting, goals and related work
Linking or clustering information that is related has been the focus of much of the related work described in \cref{sec:related}. The main goal when doing this is to construct user profiles. This is done by linking keys controlled by the same user, which will counteract the pseudo-anonymous properties of the Bitcoin system. In our project we are only interested in the subset of Bitcoin users that is also LN users, in addition to information about the LN itself. 
Our methods for locating information relevant for this have been outlined in \cref{sec:bc_analysis}, which will result in transaction subgraphs containing all on-chain transactions related to one LN channel. As we do not take the entire Bitcoin transaction graph into consideration we can not attempt to link all keys found in the blockchain; we will instead focus on linking using only data from the subgraphs-i.e., only LN related transactions. 
One relation we can attempt to link is the relation between channels based on shared user participation.
It relies on the fact that to be a usable network, the LN will need some nodes/users to have multiple channels to different users-i.e., some nodes will need to be of a degree higher than one. This relation between channels is clearly visible from the LN perspective, as the view of the network will contain this relation, but this is not the case for the blockchain. As we stated in the start of this chapter, the Bitcoin system is unaware of the working and state of the LN, meaning the there is no explicit relation based on common nodes/users participation between channel subgraphs on the blockchian. The linking can be done with any connection we can find between subgraphs, meaning most unique data found in the subgraphs allows for this type of linking. These things, in addition to on-chain transactions being used for channel management, makes channels the natural main focus of linking in this context. Because the transaction done inside LN are off-chain, linking information from the blockchian perspective will be mostly restricted to LN metadata-i.e., channel and user information, but not how the users within this network are transacting.
\\

%defining a user
While we can link channels based on a common user participating on both, but we cannot determine which of the two users in either channel creates this relation. 
The reason for this is the same as discussed in \cref{sec:bc_analysis}, where we pointed out the problems of matching inputs to outputs of a channel to see changes in balance between the users. 
In previous work discussed in \cref{sec:related} users where defined by control of a key pair, so essentially a key is a user.
Linking keys will reduce the number of users by redefining users as a set of key pairs.
E.g., a transaction graph with four keys, would mean there was four potential users, unless we managed to link keys to reduce this.
In our case with channel subgraphs, the problem arises because we know in advance how many users is involved within the transactions.
There is two users involved in a channel, but usually many more keys present, so we have a reduced user count, but this is not due to linking keys. Defining a user in this setting is harder, as we cannot simply choose a arbitrary key for each of the two users. In \cref{fig:keys_subgraphs} we see how there is 6 keys which normally could each represent a user, but in our setting we know there is only two users. If we could link the keys, to get two sets of keys belonging to each user, then this could be our definition of a user as it could be used to distinguish the users. But without creating two sets of keys we cannot take all keys into consideration and still use keys as the property to define users. Then in regards to linking channels, if one of the keys in a subgraph is found in another subgraph we can determine that one of the users is present in both, but because we do not have a clear definition of the users, not which one. We will discuss later in this section some solutions and other possibilities for defining users.
\\

%channel linking creating a channel graph
Linking channels based on shared user participation allows us to create a channel graph showing how the channels are related to each other.
In this graph the vertices represents channels and the edges represent users/nodes in the LN.
While the transaction graph for Bitcoin allows us to see how founds are moving by giving us the structure of the transaction graph, 
the channel graph can show us how found can flow between channels based on their connection by users.
As the LN is a network itself, it has a natural graph structure where vertices are users/nodes and the channels is edges between the users, which we will refer to as the LN graph.
This is the reverse in terms of vertex - edges compared to our channel graph-i.e., if vertices represents channels or users/nodes and edges represents channels or users/nodes. Another difference between the LN graph and our channel graph, is that the LN graph requires distinction between users/nodes as the vertices in that graph is a specific user; in our channel graph the edges is any of the two users participating in the vertices connected to the edge.
\\

We have used two heuristcs for linking subgraphs in this project. One of them has elements of both heuristics discussed in \cref{sec:related} used in previous work, which we will discuss later. Our heuristics for this project are: 

\begin{enumerate}

    \item \textbf{Key reuse}\\
This heuristic is simply to check if the same keys is present in different channel subgraphs.  
Any key found within a channel subgraph belongs to one of the two users participating in the channel, so if the same key can be found in another subgraph we know the user participated in the same channel.
This heuristic becomes useful because we are linking sets of transactions-i.e., subgraphs representing channels. In previous work where they linking keys, this becomes redundant as a key is obviously related to itself, but in our case we are not interested in keys as such but rather how they reveal user involvement. Because we know there is only two people participating in transactions within the subgraph, keys from any transaction inside the subgraph can be checked for reuse, with the exception of the outputs in the timelocked transaction.
\\

    \item \textbf{Graph connections}\\
This heuristic is based on channel graphs being directly connected with each other with output - input pairs. This connection can be found in any outputs going to transactions outside the graph, or in any inputs coming from any transactions outside the graph. This means all other outputs than the 2of2 mutlisig one used for the channel in the founding transaction, the non timelocked output in the closing transaction, the output of the timelocked transaction, and the inputs to the founding transaction. 
In \cref{fig:linking_graphs} we can see these connections-e.g., the non-channel output of a founding transaction is used for input in another founding transaction. The reason we can determine shared user participation in connected channel graphs is that they are directly connected. We know the purpose of the transactions in a channel graph to be controlling a LN channel, so outputs from a founding transaction should be related to this and not some other unrelated transfer. This concept is the same as the one used in previous work with heuristic 2 discussed in \cref{sec:related}, where some outputs from a transaction was assumed to be change for the sender. The non channel outputs of the founding transaction should be change back to the participants, as they may not want to use the entire value of the inputs in their channel. It is unlikely that the outputs is a transfer of funds to another entity unrelated to the channel, so we can safely assume that the outputs are controlled by one of the entities in the channel, therefore if they are used as input in another channel, it would tell us the same user is participating in both. 

    \item \textbf{Graph overlap}\\
    
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/graph_linking.png}
    \caption{Connected channel graphs}
    \label{fig:linking_graphs}
\end{figure}


















%key reuse and, graph overlap
%The heuristics discussed in \cref{sec:related} used for previous works, where created for linking key pairs, found inside a output - input which again is located in a transaction. This meant the transaction was the largest unit taken into consideration when using the heuristics-e.g., a transaction has two inputs, indicating the keys used in both output - input pairs belong to the same user. In our case we have units consisting of multiple transactions which is the subgraphs representing a channel on-chain, but some of the general idea behind the heuristics is still relevant for our use. 
%
%If we take heuristic 1 from \cref{sec:related} as a example: it was based on transactions with multiple inputs, and how they could be used to determine that the keys used for these inputs belonged to the same user.
%With key pairs being used in a output - input as discussed in \cref{subsec:scripts}, we can also determine using this heuristic that the same user participated in multiple output - input pairs. In our case this can be used to finding a such pairs in different subgraphs, thus finding a common user participating in different subgraphs. This means we will check for transactions within the subgraphs having multiple inputs from different subgraphs, which will allow us to link the channels. 
%
%
%We have used three total heuristics for linking channels in our work, two of them are based on the previous ones described in \cref{sec:related}, while the third is more specific for our case.
%These three heurisitcs can bee seen in \cref{fig:linking_subgraphs} and is described below:
%
%\begin{enumerate}
%
%    \item \textbf{Outputs from multiple subgrahps being inputs in one transaction} (green circle) \\
% The first heuristic is having multiple inputs from different subgraphs in the same transaction, same as we discussed in the paragraph above.
% It is in the timelocked transaction this 
%    
%    \item \textbf{Change output used as input in another subgraph} (blue circle) \\
% The second heuristic is based on heuristic 2 discussed in \cref{sec:related} where some outputs was considered to be shadow addresses used by the creator of the transaction to receive change. Because we know there are two users participating in a subgraph and the purpose of the transactions is to operate channels, the outputs from the founding transaction going "outside" the subgraph should be to receive change from the creation of the channel. If this change output is used as input for a transaction in another subgraph we can link the two based on this.
% The only transactions in the subgraph which uses inputs from "outside" the subgraph is the founding input transactions, so it is here we will potentially find the output - input connection from the founding transaction in another subgraph.
% Theis heuristic is one of the main reasons we include the founding input transaction transaction in the channel subgraph. As these transactions provide the input to the founding transaction, at least the outputs used for this are controlled by the participants in the channel, and therefore if they use a output from another channel we can determine the same user was present in both. 
% 
%    \item \textbf{Key Reuse in different subgraphs} (red cirlce)\\
%    
%    
% \item \textbf{Same transactions present in multiple graphs} (ssss) \\
% As mentioned in \cref{sec:bc_analysis} the timelocked transaction in one subgraph can even be the founding input transaction in another, meaning the founding input can also provide overlap with the transaction graphs and not just a direct link with input - outputs.
% 
%\end{enumerate}
%%todo, single founded tx, linking not possible if all founds tranasferred.
%Defining a user when linking channels and using all information in the subgraph was problematic, but we can avoid this by only considering the keys in the 2of2 multisig output - input pair at the core of the channel subgraph. Using only these two keys will allow us  to differentiate the two users, and if any of the two keys is reused in other 2of2 multisig channel output - input pair we can determine which of the users is present in the other channel. Having clearly defined users we can identify in different channels would allow us to create a network where users is linked by participation in channels, similarly to the channel graph but here we can differentiate the users.
%In such a network nodes would be users and edges channels between them, giving us the a network with a view like the standard LN view. However, when only considering this single output - input pair we have very little information to use for linking; we can not use the rest of the transactions in the subgraph as we run into the differentiating users problem again if we are unable to link the keys in the subgraph, so in our tests we have only done linking based on key reuse in the 2of2 multisig channel input - output. 