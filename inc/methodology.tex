\chapter{Methodology and Implementation}
\label{chap:metodology}

Our goal with this project as outlined in \cref{chap:introduction} is creating a method for identifying LN relevant transactions on the blockchain and discover what information will be available to us by doing so. The LN is a separate network but the on-chain transactions it requires for operating channels gives us a link between the two. Because we are interested in what we can learn about the LN and its users from analyzing the blockchain, we will not utilize the information in non LN relevant transactions or users in this project. Reason behind this is the size of the blockchain as discussed in \cref{sec:related}, which means the requirements for both software and hardware will be high if all information should be kept track for parsing. The benefits of taking all information into consideration are also small four our project, however, it can be helpful and is discussed further in \cref{sec:future} on future work. 
\\

The link between the LN and the Bitcoin network will only provide us with a portion of the information about the LN and its users. By connecting to the LN itself we would have access to more information than found on the blockchain. However, the LN is a dynamic changing network of nodes, channels, and payment's; which is not stored in any public ledger like the blockchain. The information found in the LN can be recorded and stored by participants but the system itself does not keep such a record. The data in the blockchain can be verified by any user as explained in \cref{subsec:blockchain} while data recorded from the LN could not be verified in the same manner on its own.
This means that if we want historical data about the LN we must use the blockchain in which the users maintain a consensus about its correctness. Because as already stated the LN requires the Bitcoin system to operate so there will be on-chain transactions on the blockchain. We can also use the fact that there is much information available from connecting to the LN itself: collecting this information will allow us compare it with what we find on the blockchain. Doing this comparison we can verify our method for identifying LN relevant transactions on the blockchain. 
In this project we have created a method for identifying LN relevant transactions while parsing the blockchain, collected data from the LN to compare to the blockchain data, and applied methods for linking relevant information to reveal non-explicit information. 
%analysis of anonymity include.

\section{Blockchain analysis}

The transactions in the blockchain is linked with outputs - inputs forming a DAG as we explained in \cref{subsec:transactions}. Parsing the blockchain would entail linking these transactions to form a transaction graph. When applying the heuristics used by previous works discussed in \cref{sec:background} one can use the information discovered there to provide context to the graph. In our work we do not create a complete transaction graph; we only link transactions related to a single LN channel which gives us a set of sub graphs of the complete transaction graph, each representing LN a channel. Only creating these small sub graphs is considerably easier because we do not need keep track as much data when the parsing is done. To create these graphs we must first differentiate between on-chain LN transactions and normal Bitcoin transactions.
\\

To locate LN relevant transaction on the blockchain we identified attributes they contained not present in other transactions. As stated in \cref{subsec:pcln} Lightning channels have two main on-chain transactions: the founding/opening and closing transaction as seen in \cref{fig:ln_tx_graph} with the two middle transactions. The founding transaction will contain the channel output, and the closing transaction will have the channel input. This output - input pair will be of the type P2WSH 2of2 mutlsig as stated in \cref{subsec:pcln}. This will be the case for all output - input pairs used for these on-chain transactions, but it is not sufficient to determine if a transaction is related to the LN or not, because P2WSH 2of2 multisig transactions can be used for other purposes. As we explained in \cref{subsec:scripts} a P2SH (non segwit version of P2WSH) lock type will only have the hash of the script in the output, while the redeem script itself is included in the input of the spending transaction. This means that if we only consider a founding transaction output we will only be able to tell if the output is a P2WSH type, but if we only look at the closing tx input we will be able to tell that the type is P2WSH and that the redeem script is a 2of2 multisig script. Since both properties must be present in a LN channel output - input pair, we can say that it is more likely the transactions containing the inputs is relevant to LN based on the closing transaction rather than the founding tx. While this method cannot determine if transactions is related to the LN or not, it allows us to say that the transactions types in question are likelier than others to be LN related. We will discuss identification using this method later in this chapter.
\\

In addition to 2of2 multisig redeem scripts there is other script types used in certain LN on-chain transactions. One of these scripts is the one used when a channel is unilaterally closed-i.e., one of the parties in the channel publishes a commitment transaction. As explained in section \cref{subsec:pcln} the one who publishes a commitment transaction has their output of the commitment timelocked; this is to enable punishment for the publisher if the commitment in question was a revoked one with outdated balance favoring the publisher more than the most recent commitment. As stated in the LN specification \cite{bolt3} this unilaterally published commitment transaction has two outputs: one P2WPKH to the party who did not publish, and one P2WSH output with a redeem script which can be spent by waiting for the timelock it contains or with a revocation key. 
This redeem script is fairly unique and to our knowledge there is no other instances such scripts are used. However, people are free to create such scripts without it having anything to do with the LN, but the specific use case of such script makes this unlikely. Because the redeem script is located in the transaction spending a P2WSH output, we need for this case locate it in the transaction spending the timelocket output from the closing/commitment transaction. We will refer to this as the timelocked transaction which is shown on the right in \cref{fig:ln_tx_graph}. Since transactions have references to previous transaction hashes \todo{check if transaction hashes is explaned in bckground} we can by finding the transaction spending a timelocked output get the hash of the timelocked tx. When we have the timelocked tx it will contain the hash of the input tx, and this will again allow us to find the tx hash of the closing tx which will in turn give us the founding tx. Doing this will result in us finding all on-chain transactions related to a unilatirally closed lightning channels.

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/ln_tx_graph.png}
    \caption{Transaction subgraph of unilaterally closed channel}
    \label{fig:ln_tx_graph}
\end{figure}


This method identify the transactions related to a lightning channel in reverse order meaning the transaction spending the timelocked output will be indentified first and the founding transaction last. 
This means we must parse the blockchain in reverse order starting from the lastest block working our way down the the start; the structure of the blockchain with blocks only contain the hash of the previous block is another reason for this.
For this project we have developed software parsing the blockchain and identified relevant transaction as outlined above.
At a high level the software finds the top block from the chaindata stored in the database and uses it as a starting point.
Then it traverses the transactions in the block and checks if they are relevant for our project, if that is the case they are stored for later use. The hash of the preceding block is used to get it from the database and same process is repeated.
The algorithm used is based on identifying scripts from the timelocked output of a unilaterally closed channel, and then using the transaction hash of the previous transaction to get the rest of the relevant channels as shown in fig. \todo{add ref fig}

\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{figures/algorithm.png}
    \caption{Algorithm of parsing and locating relevant LN transactions on the blockchain}
    \label{fig:htlc_bc}
\end{figure}

% ln transaction formats on chain

When a transaction is inspected we first check if it has a input containing a redeem script for a timelocked transaction.
The script is defined in the lightning rfc \todo{add ref to rfc} and has the format:
\\

\noindent OP\_IF \\
    # Penalty transaction \\
    <revocationpubkey> \\
OP\_ELSE\\
    `to\_self\_delay`\\
    OP\_CSV\\
    OP\_DROP\\
    <local\_delayedpubkey>\\
OP\_ENDIF\\
OP\_CHECKSIG\\

The first line is the clause to stop participants from publishing old commitment transactions. The script will evaluate to true if this clause is used and the signature for the public key is given; As discussed in section \todo{ref bacground} the parties will revoke old commitment transactions by exchanging keys so the other party can spend the timelocked output with the revocation key and get all the founds in the channel. The else clause is the timelocked portion of the script; it will contain a delay and the CHECKSEQUENCEVERIFY operation defined in \todo{ref bip 112} which terminates the script if the delay has not passed. The delay is then removed from the stack with OP\_DROP such that the signature and public key are the only two items on the stack when OP\_CHECKSIG is used to very the signature.

% identifying scripts in depth

% multisig detection

% how other information gathered. output types so on.

\section{Lightning network analysis}

% lnd introduction

%why gather ln data (relate to background and goals)

%how ln data was gathered

To gather data from the LN we used a modified version of the LND \todo{add ref} implementation, which follows the BOLT specification \todo{add ref}. It maintains a view of the network by storing a graph containing active channels. This is continuously updated as new channels are annouched and closing transactions is found on the blockchain. It requires a bitcoin backend running to interact with the bitcoin network; using it to publish on-chain transactions and monitor the blockchain. New channels are discovered by annouchements within the LN while channels closing is found by looking at the blockchain and finding transactions spending the founding transactions of previously active channels. We forked and modifed LND to create a copy of its database each time a new block notification was received from the Bitcoin software giving us a snapshot of the network on each new block.
\\

Each snapshot we collected contained the graph describing the network in its current state, so by comparing the graphs of different snapshorts we can see how the network evolves over time. When comparing two snapshots from two points in time we can identify closed channels by checking the old snapshot for channels not found in the new one; Similarly new channels can be found by checking the new snapshot for channels not found in the old one. This allows us to build a list of closed and opened channels during the collection timeframe, as well as the those which are open throughout. 

% details getting channels.

% comparing to blockchain data

\section{Clustering}

% intro clusting, goals and related work

% how we cluster channels and so on.